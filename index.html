<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Translate Blitz: A comprehensive English-to-Spanish translation game with enhanced voice recognition.">
  <title>Translate Blitz Pro - Enhanced Voice</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-x: hidden;
    }

    .game-container {
      max-width: 900px;
      width: 100%;
      text-align: center;
    }

    .game-header {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .game-title {
      font-size: 3rem;
      font-weight: 700;
      color: #ffd700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      margin-bottom: 10px;
    }

    .game-subtitle {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 20px;
    }

    canvas {
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(5px);
    }

    .controls-panel {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      padding: 25px;
      margin: 20px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
      align-items: center;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .input-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    input, select, button {
      padding: 12px 18px;
      font-size: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      color: #fff;
      transition: all 0.3s ease;
      min-width: 200px;
    }

    input::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }

    input:focus, select:focus {
      outline: none;
      border-color: #ffd700;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      background: rgba(255, 255, 255, 0.2);
    }

    button {
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
      border: none;
      color: white;
      font-weight: 600;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }

    .start-button {
      background: linear-gradient(45deg, #56ab2f, #a8e6cf);
      font-size: 1.1rem;
      padding: 15px 30px;
      border-radius: 25px;
    }

    .loading-container {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      margin: 15px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .loading-text {
      color: rgba(255, 255, 255, 0.9);
      font-size: 1.1rem;
      font-weight: 500;
      margin-bottom: 15px;
    }

    .progress-container {
      width: 100%;
      max-width: 500px;
      margin: 15px auto;
    }

    .progress-bar {
      width: 100%;
      height: 12px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #ffd700, #ffed4e);
      border-radius: 6px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .progress-stats {
      display: flex;
      justify-content: space-between;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.9rem;
    }

    .word-stats {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 15px;
      margin: 10px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      margin-top: 10px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }

    .stat-number {
      font-size: 1.5rem;
      font-weight: 700;
      color: #ffd700;
      display: block;
    }

    .stat-label {
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.8rem;
      text-transform: uppercase;
    }

    .file-info {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 15px;
      margin: 10px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .game-info {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 15px;
      margin: 10px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .current-word {
      font-size: 2.5rem;
      font-weight: 700;
      color: #ffd700;
      margin: 20px 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .timer-display {
      font-size: 1.8rem;
      font-weight: 600;
      padding: 10px 20px;
      border-radius: 25px;
      background: rgba(255, 255, 255, 0.1);
      display: inline-block;
      margin: 10px 0;
      color: #4ecdc4;
      border: 2px solid #4ecdc4;
    }

    .translation-input {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      margin: 15px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .voice-recognition {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 25px;
      margin: 15px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .voice-title {
      font-size: 1.5rem;
      color: #ffa726;
      font-weight: 600;
      margin-bottom: 20px;
    }

    .pronunciation-audio {
      background: rgba(255, 167, 38, 0.2);
      border: 1px solid #ffa726;
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
    }

    .pronunciation-controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 15px 0;
      flex-wrap: wrap;
    }

    .play-button {
      background: linear-gradient(45deg, #ffa726, #ff7043);
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      font-size: 1.5rem;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .play-button:hover {
      transform: scale(1.1);
    }

    .pronunciation-rounds {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin: 20px 0;
    }

    .round-card {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      border: 2px solid transparent;
      transition: all 0.3s ease;
    }

    .round-pending {
      border-color: rgba(255, 255, 255, 0.3);
      color: rgba(255, 255, 255, 0.7);
    }

    .round-active {
      border-color: #ffa726;
      background: rgba(255, 167, 38, 0.2);
      color: #ffa726;
      animation: pulse 1s ease-in-out infinite;
    }

    .round-success {
      border-color: #4ecdc4;
      background: rgba(78, 205, 196, 0.2);
      color: #4ecdc4;
    }

    .round-failed {
      border-color: #ff6b6b;
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
    }

    .mic-button {
      background: linear-gradient(45deg, #ff6b6b, #ffa726);
      border: none;
      border-radius: 50%;
      width: 100px;
      height: 100px;
      font-size: 2.5rem;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 20px auto;
      display: block;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    .mic-button:hover {
      transform: scale(1.05);
    }

    .mic-button.recording {
      background: linear-gradient(45deg, #ff4757, #ff3838);
      animation: recording 1s ease-in-out infinite;
      box-shadow: 0 0 30px rgba(255, 71, 87, 0.6);
    }

    .mic-volume-indicator {
      position: absolute;
      top: -10px;
      right: -10px;
      background: #4ecdc4;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      animation: pulse 0.5s ease-in-out infinite;
    }

    .voice-feedback {
      margin: 15px 0;
      padding: 15px;
      border-radius: 10px;
      font-size: 1.1rem;
      font-weight: 500;
    }

    .feedback-success {
      background: rgba(78, 205, 196, 0.2);
      border: 1px solid #4ecdc4;
      color: #4ecdc4;
    }

    .feedback-error {
      background: rgba(255, 107, 107, 0.2);
      border: 1px solid #ff6b6b;
      color: #ff6b6b;
    }

    .feedback-info {
      background: rgba(255, 167, 38, 0.2);
      border: 1px solid #ffa726;
      color: #ffa726;
    }

    .pronunciation-score {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      margin: 20px 0;
    }

    .score-item {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }

    .score-value {
      font-size: 1.2rem;
      font-weight: 700;
      color: #ffd700;
      display: block;
    }

    .score-label {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.8);
      text-transform: uppercase;
    }

    .voice-wave {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 3px;
      margin: 15px 0;
    }

    .wave-bar {
      width: 4px;
      height: 20px;
      background: #ffa726;
      border-radius: 2px;
      animation: wave 1.5s ease-in-out infinite;
    }

    .wave-bar:nth-child(2) { animation-delay: 0.1s; }
    .wave-bar:nth-child(3) { animation-delay: 0.2s; }
    .wave-bar:nth-child(4) { animation-delay: 0.3s; }
    .wave-bar:nth-child(5) { animation-delay: 0.4s; }

    .microphone-setup {
      background: rgba(255, 167, 38, 0.1);
      border: 1px solid #ffa726;
      border-radius: 10px;
      padding: 15px;
      margin: 15px 0;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.9);
    }

    .errors-review {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      padding: 25px;
      margin: 20px 0;
      max-width: 800px;
      width: 100%;
      display: none;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    @keyframes recording {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255, 71, 87, 0.6); }
      50% { transform: scale(1.1); box-shadow: 0 0 50px rgba(255, 71, 87, 0.9); }
    }

    @keyframes wave {
      0%, 100% { height: 20px; }
      50% { height: 40px; }
    }

    .processing-indicator {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top: 3px solid #ffd700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }

    @media (max-width: 768px) {
      .game-title {
        font-size: 2rem;
      }
      
      .controls-panel {
        flex-direction: column;
        padding: 20px;
      }
      
      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .pronunciation-rounds {
        grid-template-columns: 1fr;
        gap: 10px;
      }
      
      .mic-button {
        width: 80px;
        height: 80px;
        font-size: 2rem;
      }
      
      canvas {
        width: 100% !important;
        height: auto !important;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="game-header">
      <h1 class="game-title">🌟 Translate Blitz Pro</h1>
      <p class="game-subtitle">Enhanced Voice Recognition & Pronunciation Training</p>
    </div>

    <div class="controls-panel" id="controlsPanel">
      <div class="input-group">
        <label class="input-label">📁 Upload Vocabulary File</label>
        <input type="file" id="fileInput" accept=".txt">
      </div>
      
      <div class="input-group">
        <label class="input-label">⚡ Difficulty</label>
        <select id="typeSelect">
          <option value="beginner">🐢 Beginner (25s per word)</option>
          <option value="easy">🐌 Easy (15s per word)</option>
          <option value="medium">🚀 Medium (8s per word)</option>
          <option value="hard">⚡ Hard (3s per word)</option>
        </select>
      </div>
      
      <div class="input-group">
        <label class="input-label">📊 Round Size</label>
        <select id="roundSizeSelect">
          <option value="25">25 Words</option>
          <option value="50">50 Words</option>
          <option value="100">100 Words</option>
          <option value="half">Half Collection</option>
          <option value="all">All Words</option>
        </select>
      </div>
    </div>

    <div class="file-info" id="fileInfo">
      <h3 style="color: #ffd700; margin-bottom: 10px;">📄 File Analysis</h3>
      <div class="stats-grid">
        <div class="stat-card">
          <span class="stat-number" id="totalWordsCount">0</span>
          <span class="stat-label">Total Words</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="uniqueWordsCount">0</span>
          <span class="stat-label">Unique Words</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="sentencesCount">0</span>
          <span class="stat-label">Sentences</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="charactersCount">0</span>
          <span class="stat-label">Characters</span>
        </div>
      </div>
    </div>

    <div class="loading-container" id="loadingContainer">
      <div class="loading-text" id="loadingText">
        <span class="processing-indicator"></span>
        Processing vocabulary with comprehensive translation...
      </div>
      
      <div class="progress-container">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-stats">
          <span id="progressText">Initializing...</span>
          <span id="progressPercent">0%</span>
        </div>
      </div>

      <div class="word-stats" id="wordStats">
        <div class="stats-grid">
          <div class="stat-card">
            <span class="stat-number" id="processedCount">0</span>
            <span class="stat-label">Processed</span>
          </div>
          <div class="stat-card">
            <span class="stat-number" id="translatedCount">0</span>
            <span class="stat-label">Translated</span>
          </div>
          <div class="stat-card">
            <span class="stat-number" id="failedCount">0</span>
            <span class="stat-label">Failed</span>
          </div>
          <div class="stat-card">
            <span class="stat-number" id="cacheHits">0</span>
            <span class="stat-label">Cache Hits</span>
          </div>
        </div>
      </div>
    </div>

    <button class="start-button" id="startButton">
      🚀 Start Game
    </button>

    <div class="game-info" id="gameInfo">
      <div class="current-word" id="currentWordDisplay"></div>
      <div class="timer-display" id="timerDisplay"></div>
      <div class="stats-grid">
        <div class="stat-card">
          <span class="stat-number" id="scoreDisplay">0</span>
          <span class="stat-label">Score</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="correctDisplay">0</span>
          <span class="stat-label">Correct</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="incorrectDisplay">0</span>
          <span class="stat-label">Incorrect</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="roundDisplay">0/0</span>
          <span class="stat-label">Progress</span>
        </div>
      </div>
    </div>

    <div class="translation-input" id="translationInput">
      <div style="color: rgba(255, 255, 255, 0.9); font-size: 1.1rem; margin-bottom: 15px;">Type your Spanish translation:</div>
      <input type="text" id="inputTranslation" placeholder="Enter Spanish translation..." autocomplete="off">
      <button style="background: linear-gradient(45deg, #667eea, #764ba2); min-width: 150px; margin-top: 10px;" id="submitButton">
        ✅ Submit Answer
      </button>
    </div>

    <div class="voice-recognition" id="voiceRecognition">
      <div class="voice-title">🎤 Enhanced Voice Pronunciation Practice</div>
      <div style="color: rgba(255, 255, 255, 0.9); margin-bottom: 20px; font-size: 1.1rem; text-align: center;">
        Practice pronouncing: "<span id="pronunciationWord" style="color: #ffd700; font-weight: 600; font-size: 1.3rem;"></span>"
      </div>

      <div class="pronunciation-audio">
        <div style="color: #ffa726; font-weight: 600; margin-bottom: 15px; text-align: center;">
          🔊 Listen to the correct pronunciation (click as many times as needed):
        </div>
        <div class="pronunciation-controls">
          <button class="play-button" id="playPronunciation" title="Play pronunciation">
            ▶️
          </button>
          <button class="play-button" id="playSlowPronunciation" title="Play slow pronunciation">
            🐌
          </button>
          <button class="play-button" id="repeatPronunciation" title="Repeat 3 times">
            🔄
          </button>
        </div>
        <div style="text-align: center; color: rgba(255, 255, 255, 0.8); font-size: 0.9rem; margin-top: 10px;">
          Phonetic: <span id="phoneticDisplay" style="font-family: monospace; color: #ffa726;"></span>
        </div>
      </div>

      <div class="microphone-setup">
        <div style="font-weight: 600; margin-bottom: 10px; color: #ffa726;">🎤 Microphone Enhanced for Better Detection:</div>
        <div style="font-size: 0.85rem; line-height: 1.4;">
          • Automatic gain control enabled<br>
          • Noise reduction active<br>
          • Pronunciation tolerance: Relaxed (50%+ similarity accepted)<br>
          • Speak clearly and at normal volume
        </div>
      </div>

      <div class="pronunciation-rounds" id="pronunciationRounds">
        <div class="round-card round-pending" id="round1">
          <div style="font-size: 1.5rem; margin-bottom: 5px;">🎯</div>
          <div style="font-weight: 600;">Round 1</div>
          <div style="font-size: 0.8rem; margin-top: 5px;" id="round1Status">Pending</div>
        </div>
        <div class="round-card round-pending" id="round2">
          <div style="font-size: 1.5rem; margin-bottom: 5px;">🎯</div>
          <div style="font-weight: 600;">Round 2</div>
          <div style="font-size: 0.8rem; margin-top: 5px;" id="round2Status">Pending</div>
        </div>
        <div class="round-card round-pending" id="round3">
          <div style="font-size: 1.5rem; margin-bottom: 5px;">🎯</div>
          <div style="font-weight: 600;">Round 3</div>
          <div style="font-size: 0.8rem; margin-top: 5px;" id="round3Status">Pending</div>
        </div>
      </div>

      <button class="mic-button" id="micButton" title="Click to start recording">
        🎤
        <div class="mic-volume-indicator" id="volumeIndicator">📊</div>
      </button>

      <div class="voice-wave" id="voiceWave" style="display: none;">
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
      </div>

      <div id="voiceFeedback"></div>

      <div class="pronunciation-score" id="pronunciationScore">
        <div class="score-item">
          <span class="score-value" id="accuracyScore">0%</span>
          <span class="score-label">Accuracy</span>
        </div>
        <div class="score-item">
          <span class="score-value" id="clarityScore">0%</span>
          <span class="score-label">Clarity</span>
        </div>
        <div class="score-item">
          <span class="score-value" id="speedScore">0%</span>
          <span class="score-label">Speed</span>
        </div>
        <div class="score-item">
          <span class="score-value" id="overallScore">0%</span>
          <span class="score-label">Overall</span>
        </div>
      </div>
    </div>

    <div class="errors-review" id="errorsReview">
      <h2 style="color: #ff6b6b; font-size: 1.5rem; font-weight: 600; margin-bottom: 20px; text-align: center;">📝 Review Your Mistakes</h2>
      <div id="errorsList"></div>
      <button class="start-button" id="retryButton">
        🔄 Practice Again
      </button>
    </div>

    <div class="stats-grid" id="finalStats" style="display: none; margin: 20px 0;">
      <div class="stat-card">
        <span class="stat-number" id="finalScore">0</span>
        <span class="stat-label">Final Score</span>
      </div>
      <div class="stat-card">
        <span class="stat-number" id="finalAccuracy">0%</span>
        <span class="stat-label">Translation</span>
      </div>
      <div class="stat-card">
        <span class="stat-number" id="finalTime">0s</span>
        <span class="stat-label">Avg Time</span>
      </div>
      <div class="stat-card">
        <span class="stat-number" id="pronunciationAccuracy">0%</span>
        <span class="stat-label">Pronunciation</span>
      </div>
    </div>
  </div>

  <script>
    // Game state variables
    let phrases = [];
    let currentPhrase = null;
    let score = 0;
    let correctAnswers = 0;
    let incorrectTranslations = 0;
    let timeLeft = 15;
    let gameState = 'waiting';
    let round = 0;
    let roundSize = 25;
    let errors = [];
    let currentPhraseIndex = 0;
    let fileLoaded = false;
    let difficultyTimes = { beginner: 25, easy: 15, medium: 8, hard: 3 };
    let particles = [];
    let color1, color2;
    let countdownTimer = 0;
    let processingWords = false;
    let processedCount = 0;
    let translatedCount = 0;
    let failedCount = 0;
    let cacheHits = 0;
    let totalWords = 0;
    let startTime = 0;
    let totalGameTime = 0;
    let currentRoundWords = [];
    let waitingForPronunciation = false;
    let pronunciationAttempts = 0;
    let maxPronunciationAttempts = 3;
    let translationCache = {};

    // Enhanced voice recognition variables
    let recognition = null;
    let isRecording = false;
    let currentPronunciationRound = 1;
    let pronunciationResults = [];
    let speechSynthesis = window.speechSynthesis;
    let totalPronunciationScore = 0;
    let pronunciationStartTime = 0;
    let audioContext = null;
    let mediaStream = null;
    let analyser = null;
    let microphone = null;
    let gainNode = null;

    // Enhanced translation dictionary
    const translationDictionary = {
      'hello': ['hola'], 'hi': ['hola'], 'goodbye': ['adiós'], 'bye': ['adiós'], 
      'please': ['por favor'], 'thank you': ['gracias'], 'thanks': ['gracias'], 
      'sorry': ['lo siento'], 'excuse me': ['disculpe'], 'yes': ['sí'], 'no': ['no'],
      'time': ['tiempo', 'hora'], 'day': ['día'], 'night': ['noche'], 'morning': ['mañana'], 
      'afternoon': ['tarde'], 'evening': ['noche'], 'today': ['hoy'], 'yesterday': ['ayer'], 
      'tomorrow': ['mañana'], 'week': ['semana'], 'month': ['mes'], 'year': ['año'],
      'one': ['uno'], 'two': ['dos'], 'three': ['tres'], 'four': ['cuatro'], 'five': ['cinco'],
      'six': ['seis'], 'seven': ['siete'], 'eight': ['ocho'], 'nine': ['nueve'], 'ten': ['diez'],
      'red': ['rojo'], 'blue': ['azul'], 'green': ['verde'], 'yellow': ['amarillo'], 
      'orange': ['naranja'], 'purple': ['morado'], 'pink': ['rosa'], 'brown': ['marrón'], 
      'black': ['negro'], 'white': ['blanco'], 'gray': ['gris'], 'grey': ['gris'],
      'family': ['familia'], 'mother': ['madre'], 'father': ['padre'], 'mom': ['mamá'], 
      'dad': ['papá'], 'sister': ['hermana'], 'brother': ['hermano'], 'son': ['hijo'], 
      'daughter': ['hija'], 'friend': ['amigo'], 'person': ['persona'], 'people': ['gente'],
      'head': ['cabeza'], 'face': ['cara'], 'eye': ['ojo'], 'nose': ['nariz'], 'mouth': ['boca'],
      'hand': ['mano'], 'arm': ['brazo'], 'leg': ['pierna'], 'foot': ['pie'], 'heart': ['corazón'],
      'dog': ['perro'], 'cat': ['gato'], 'bird': ['pájaro'], 'fish': ['pez'], 'horse': ['caballo'],
      'food': ['comida'], 'water': ['agua'], 'bread': ['pan'], 'milk': ['leche'], 'meat': ['carne'],
      'apple': ['manzana'], 'banana': ['plátano'], 'orange': ['naranja'], 'coffee': ['café'],
      'house': ['casa'], 'home': ['hogar'], 'school': ['escuela'], 'work': ['trabajo'], 
      'city': ['ciudad'], 'country': ['país'], 'world': ['mundo'],
      'be': ['ser', 'estar'], 'have': ['tener'], 'do': ['hacer'], 'say': ['decir'], 'go': ['ir'],
      'come': ['venir'], 'see': ['ver'], 'eat': ['comer'], 'drink': ['beber'], 'sleep': ['dormir'],
      'walk': ['caminar'], 'run': ['correr'], 'play': ['jugar'], 'read': ['leer'], 'write': ['escribir'],
      'speak': ['hablar'], 'listen': ['escuchar'], 'watch': ['ver'], 'learn': ['aprender'],
      'good': ['bueno'], 'bad': ['malo'], 'big': ['grande'], 'small': ['pequeño'], 
      'hot': ['caliente'], 'cold': ['frío'], 'new': ['nuevo'], 'old': ['viejo'], 
      'happy': ['feliz'], 'sad': ['triste'], 'beautiful': ['hermoso'], 'ugly': ['feo'],
      'how are you': ['cómo estás'], 'what is your name': ['cómo te llamas'], 
      'nice to meet you': ['mucho gusto'], 'i love you': ['te amo'], 'see you later': ['hasta luego'],
      'good morning': ['buenos días'], 'good night': ['buenas noches'], 'excuse me': ['disculpe'],
      'i am sorry': ['lo siento'], 'you are welcome': ['de nada'], 'how much': ['cuánto'],
      'where is': ['dónde está'], 'i do not understand': ['no entiendo'], 'help me': ['ayúdame'],
      'i need': ['necesito'], 'i want': ['quiero'], 'i like': ['me gusta']
    };

    // Particle system
    class Particle {
      constructor() {
        this.x = Math.random() * 600;
        this.y = Math.random() * 400;
        this.size = Math.random() * 4 + 2;
        this.speedX = (Math.random() - 0.5) * 2;
        this.speedY = Math.random() * 2 + 1;
        this.alpha = Math.random() * 150 + 100;
        this.color = [255, 255, 255];
        this.life = 1.0;
        this.decay = Math.random() * 0.01 + 0.005;
      }
      
      update() {
        this.x += this.speedX;
        this.y -= this.speedY;
        this.life -= this.decay;
        
        if (this.y < -this.size || this.life <= 0) {
          this.reset();
        }
        
        if (this.x < 0 || this.x > 600) {
          this.speedX *= -1;
        }
      }
      
      reset() {
        this.x = Math.random() * 600;
        this.y = 400 + this.size;
        this.life = 1.0;
      }
      
      display() {
        noStroke();
        fill(this.color[0], this.color[1], this.color[2], this.alpha * this.life);
        ellipse(this.x, this.y, this.size * this.life);
      }
    }

    // Enhanced Voice Recognition Setup with Amplification
    async function initializeEnhancedVoiceRecognition() {
      console.log('🎤 Initializing enhanced voice recognition with amplification...');
      
      try {
        // Initialize Web Audio API for amplification
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        // Request microphone access with enhanced settings
        const constraints = {
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 44100,
            channelCount: 1,
            volume: 1.0
          }
        };
        
        mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        console.log('✅ Microphone access granted with enhanced settings');
        
        // Set up audio processing for amplification
        setupAudioAmplification(mediaStream);
        
        // Initialize speech recognition
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          recognition = new SpeechRecognition();
          
          // Enhanced recognition settings
          recognition.continuous = false;
          recognition.interimResults = false;
          recognition.lang = 'en-US';
          recognition.maxAlternatives = 5; // More alternatives for better matching
          
          recognition.onstart = function() {
            console.log('🎤 Enhanced voice recognition started');
            isRecording = true;
            updateMicButton();
            showVoiceWave();
            showFeedback('🎤 Listening with enhanced sensitivity... Speak clearly!', 'info');
            startVolumeMonitoring();
          };
          
          recognition.onend = function() {
            console.log('🎤 Voice recognition ended');
            isRecording = false;
            updateMicButton();
            hideVoiceWave();
            stopVolumeMonitoring();
          };
          
          recognition.onresult = function(event) {
            console.log('🗣️ Processing speech results...');
            
            // Process all alternatives for better matching
            const results = [];
            for (let i = 0; i < event.results[0].length; i++) {
              results.push({
                transcript: event.results[0][i].transcript.toLowerCase().trim(),
                confidence: event.results[0][i].confidence
              });
            }
            
            // Find best match
            const bestResult = findBestMatch(results, currentPhrase.english.toLowerCase());
            console.log(`🎯 Best match: "${bestResult.transcript}" (confidence: ${(bestResult.confidence * 100).toFixed(1)}%)`);
            
            processPronunciationResult(bestResult.transcript, bestResult.confidence);
          };
          
          recognition.onerror = function(event) {
            console.error('🚫 Speech recognition error:', event.error);
            isRecording = false;
            updateMicButton();
            hideVoiceWave();
            stopVolumeMonitoring();
            
            let errorMessage = 'Voice recognition error. ';
            switch(event.error) {
              case 'no-speech':
                errorMessage += 'No speech detected. Please speak louder and try again.';
                break;
              case 'audio-capture':
                errorMessage += 'Microphone not accessible. Check permissions.';
                break;
              case 'not-allowed':
                errorMessage += 'Microphone permission denied. Please allow access.';
                break;
              case 'network':
                errorMessage += 'Network error. Check connection and try again.';
                break;
              default:
                errorMessage += 'Please try speaking more clearly.';
            }
            
            showFeedback(errorMessage, 'error');
          };
          
          console.log('✅ Enhanced voice recognition initialized successfully');
          return true;
        } else {
          throw new Error('Speech recognition not supported');
        }
        
      } catch (error) {
        console.error('❌ Error initializing enhanced voice recognition:', error);
        showFeedback('Enhanced voice recognition not available. Please check microphone permissions.', 'error');
        return false;
      }
    }

    function setupAudioAmplification(stream) {
      try {
        // Create audio nodes for amplification
        microphone = audioContext.createMediaStreamSource(stream);
        gainNode = audioContext.createGain();
        analyser = audioContext.createAnalyser();
        
        // Set up amplification (increase gain for better detection)
        gainNode.gain.value = 2.5; // Amplify input by 2.5x
        
        // Configure analyser for volume monitoring
        analyser.fftSize = 256;
        analyser.smoothingTimeConstant = 0.8;
        
        // Connect audio nodes
        microphone.connect(gainNode);
        gainNode.connect(analyser);
        
        console.log('🔊 Audio amplification setup complete (2.5x gain)');
      } catch (error) {
        console.error('❌ Error setting up audio amplification:', error);
      }
    }

    function findBestMatch(results, targetWord) {
      let bestMatch = results[0];
      let bestSimilarity = 0;
      
      for (let result of results) {
        const similarity = calculateEnhancedSimilarity(result.transcript, targetWord);
        const weightedScore = (similarity * 0.7) + (result.confidence * 100 * 0.3);
        
        if (weightedScore > bestSimilarity) {
          bestSimilarity = weightedScore;
          bestMatch = result;
        }
      }
      
      return bestMatch;
    }

    function calculateEnhancedSimilarity(spoken, target) {
      // Enhanced similarity calculation with relaxed matching
      const spokenNorm = normalizeForComparison(spoken);
      const targetNorm = normalizeForComparison(target);
      
      console.log(`🔍 Comparing: "${spokenNorm}" vs "${targetNorm}"`);
      
      // Exact match - highest score
      if (spokenNorm === targetNorm) {
        console.log('✅ Exact match found!');
        return 100;
      }
      
      // Check if spoken contains target or vice versa
      if (spokenNorm.includes(targetNorm) || targetNorm.includes(spokenNorm)) {
        console.log('✅ Partial match found!');
        return 85;
      }
      
      // Levenshtein distance with relaxed threshold
      const distance = levenshteinDistance(spokenNorm, targetNorm);
      const maxLength = Math.max(spokenNorm.length, targetNorm.length);
      const similarity = Math.max(0, (maxLength - distance) / maxLength * 100);
      
      // Check for phonetic similarity (common mispronunciations)
      const phoneticSimilarity = checkPhoneticSimilarity(spokenNorm, targetNorm);
      
      // Use the higher score
      const finalSimilarity = Math.max(similarity, phoneticSimilarity);
      
      console.log(`📊 Similarity scores: Levenshtein=${similarity.toFixed(1)}%, Phonetic=${phoneticSimilarity.toFixed(1)}%, Final=${finalSimilarity.toFixed(1)}%`);
      
      return finalSimilarity;
    }

    function normalizeForComparison(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z\s]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function checkPhoneticSimilarity(spoken, target) {
      // Common phonetic replacements for better matching
      const phoneticMap = {
        'ph': 'f', 'th': 't', 'ck': 'k', 'ch': 'sh',
        'c': 'k', 'z': 's', 'x': 'ks', 'qu': 'kw'
      };
      
      let spokenPhonetic = spoken;
      let targetPhonetic = target;
      
      // Apply phonetic transformations
      for (let [pattern, replacement] of Object.entries(phoneticMap)) {
        spokenPhonetic = spokenPhonetic.replace(new RegExp(pattern, 'g'), replacement);
        targetPhonetic = targetPhonetic.replace(new RegExp(pattern, 'g'), replacement);
      }
      
      // Calculate similarity on phonetic versions
      const distance = levenshteinDistance(spokenPhonetic, targetPhonetic);
      const maxLength = Math.max(spokenPhonetic.length, targetPhonetic.length);
      return Math.max(0, (maxLength - distance) / maxLength * 100);
    }

    function startVolumeMonitoring() {
      if (!analyser) return;
      
      const volumeIndicator = document.getElementById('volumeIndicator');
      volumeIndicator.style.display = 'flex';
      
      function updateVolume() {
        if (!isRecording || !analyser) return;
        
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(dataArray);
        
        // Calculate average volume
        const average = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;
        const volumePercent = (average / 255) * 100;
        
        // Update volume indicator
        if (volumePercent > 20) {
          volumeIndicator.textContent = '🔊';
          volumeIndicator.style.background = '#4ecdc4';
        } else if (volumePercent > 10) {
          volumeIndicator.textContent = '🔉';
          volumeIndicator.style.background = '#ffa726';
        } else {
          volumeIndicator.textContent = '🔈';
          volumeIndicator.style.background = '#ff6b6b';
        }
        
        if (isRecording) {
          requestAnimationFrame(updateVolume);
        }
      }
      
      updateVolume();
    }

    function stopVolumeMonitoring() {
      const volumeIndicator = document.getElementById('volumeIndicator');
      volumeIndicator.style.display = 'none';
    }

    function normalizeText(text) {
      return text
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z\s]/g, '')
        .trim();
    }

    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    function generatePhonetic(word) {
      const phoneticMap = {
        'a': 'AH', 'e': 'EH', 'i': 'EE', 'o': 'OH', 'u': 'OO',
        'y': 'EE', 'ch': 'CH', 'sh': 'SH', 'th': 'TH'
      };
      
      let phonetic = word.toUpperCase();
      for (let [pattern, replacement] of Object.entries(phoneticMap)) {
        phonetic = phonetic.replace(new RegExp(pattern.toUpperCase(), 'g'), replacement);
      }
      
      return phonetic;
    }

    function setup() {
      createCanvas(600, 400);
      document.getElementById('fileInput').addEventListener('change', handleFile);
      color1 = color(102, 126, 234);
      color2 = color(118, 75, 162);
      
      // Initialize particles
      for (let i = 0; i < 40; i++) {
        particles.push(new Particle());
      }
      
      // Initialize enhanced voice recognition
      initializeEnhancedVoiceRecognition();
      
      // Load default words immediately
      loadDefaultWords();
      
      console.log('🎮 Enhanced game initialized successfully!');
      console.log(`📅 Session Date: ${getCurrentDateTime()}`);
      console.log(`👤 User: ${getCurrentUser()}`);
    }

    function loadDefaultWords() {
      phrases = [];
      const words = Object.keys(translationDictionary);
      
      console.log(`📚 Loading ${words.length} default words...`);
      
      for (let word of words) {
        const translations = translationDictionary[word];
        phrases.push({
          english: word,
          spanish: translations.map(normalizeText),
          pronunciation: `/Generated/`,
          phonetic: generatePhonetic(word)
        });
      }
      
      fileLoaded = true;
      updateUI();
      
      // Display file analysis for default words
      displayFileAnalysis({
        totalWords: words.length,
        uniqueWords: words.length,
        sentences: 0,
        characters: words.join(' ').length
      });
      
      console.log('✅ Default vocabulary loaded:', phrases.length, 'words');
    }

    function drawAnimatedBackground() {
      for (let y = 0; y < height; y++) {
        let inter = map(y, 0, height, 0, 1);
        let wave = sin(frameCount * 0.02 + y * 0.01) * 0.1;
        let c = lerpColor(color1, color2, inter + wave);
        stroke(c);
        line(0, y, width, y);
      }
      
      for (let p of particles) {
        p.update();
        p.display();
      }
    }

    function draw() {
      drawAnimatedBackground();
      
      textAlign(CENTER, CENTER);
      fill(255);
      textSize(24);
      
      switch(gameState) {
        case 'countdown':
          drawCountdown();
          break;
        case 'waiting':
          drawWaitingScreen();
          break;
        case 'playing':
          drawGameplay();
          break;
        case 'voiceRecognition':
          drawVoiceRecognition();
          break;
        case 'finalResults':
          drawFinalResults();
          break;
      }
    }

    function drawCountdown() {
      let elapsed = millis() - countdownTimer;
      let currentNumber = Math.floor(3 - elapsed / 1000);
      
      if (currentNumber < 1) {
        startMainGame();
        return;
      }
      
      textSize(100);
      fill(255, 215, 0);
      text(currentNumber, width/2, height/2);
    }

    function drawWaitingScreen() {
      if (!fileLoaded && phrases.length === 0) {
        text('🚀 Loading Game...', width/2, height/2 - 40);
        textSize(18);
        text('Preparing enhanced voice recognition', width/2, height/2 + 20);
      } else {
        text('🎯 Ready to Begin!', width/2, height/2 - 40);
        textSize(20);
        text(`${phrases.length} words loaded with enhanced voice`, width/2, height/2 + 20);
      }
    }

    function drawGameplay() {
      if (!currentPhrase) return;
      
      timeLeft -= 1 / frameRate();
      if (timeLeft <= 0) {
        handleTimeout();
        return;
      }
      
      updateGameUI();
    }

    function drawVoiceRecognition() {
      fill(255, 165, 0);
      textSize(28);
      text('🎤 Enhanced Voice Recognition', width/2, height/2 - 80);
      
      fill(255);
      textSize(24);
      text(`Practice: "${currentPhrase.english}"`, width/2, height/2 - 40);
      
      fill(255, 165, 0);
      textSize(18);
      text(`Round ${currentPronunciationRound} of 3 (Relaxed Matching)`, width/2, height/2);
      
      // Show recording status
      if (isRecording) {
        fill(255, 107, 107);
        textSize(16);
        text('🔴 Recording with amplification...', width/2, height/2 + 40);
      }
    }

    function drawFinalResults() {
      fill(255, 215, 0);
      textSize(40);
      text('🎉 Game Complete!', width/2, height/2 - 100);
      
      fill(255);
      textSize(24);
      text('Check your comprehensive results below', width/2, height/2 - 50);
      
      let accuracy = correctAnswers / (correctAnswers + incorrectTranslations) * 100;
      let avgTime = totalGameTime / (correctAnswers + incorrectTranslations);
      
      updateFinalStats(accuracy, avgTime);
    }

    function updateGameUI() {
      if (!currentPhrase) return;
      
      document.getElementById('currentWordDisplay').textContent = `"${currentPhrase.english}"`;
      document.getElementById('scoreDisplay').textContent = score;
      document.getElementById('correctDisplay').textContent = correctAnswers;
      document.getElementById('incorrectDisplay').textContent = incorrectTranslations;
      document.getElementById('roundDisplay').textContent = `${round + 1}/${roundSize}`;
      
      const timerEl = document.getElementById('timerDisplay');
      const timeDisplay = Math.ceil(timeLeft);
      timerEl.textContent = `⏰ ${timeDisplay}s`;
      
      if (timeLeft <= 3) {
        timerEl.style.color = '#ff6b6b';
        timerEl.style.borderColor = '#ff6b6b';
        timerEl.style.animation = 'pulse 0.3s ease-in-out infinite';
      } else if (timeLeft <= 5) {
        timerEl.style.color = '#ffa726';
        timerEl.style.borderColor = '#ffa726';
        timerEl.style.animation = 'pulse 0.5s ease-in-out infinite';
      } else {
        timerEl.style.color = '#4ecdc4';
        timerEl.style.borderColor = '#4ecdc4';
        timerEl.style.animation = 'none';
      }
    }

    function updateFinalStats(accuracy, avgTime) {
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalAccuracy').textContent = `${accuracy.toFixed(1)}%`;
      document.getElementById('finalTime').textContent = `${avgTime.toFixed(1)}s`;
      document.getElementById('pronunciationAccuracy').textContent = `${(totalPronunciationScore / round).toFixed(1)}%`;
      document.getElementById('finalStats').style.display = 'grid';
    }

    function updateUI() {
      if (fileLoaded && phrases.length > 0) {
        document.getElementById('startButton').style.display = 'block';
        document.getElementById('loadingContainer').style.display = 'none';
        console.log('✅ UI updated - Start button now visible');
      }
    }

    function updateProgressBar(progress) {
      const progressPercent = Math.floor(progress * 100);
      document.getElementById('progressFill').style.width = progressPercent + '%';
      document.getElementById('progressPercent').textContent = progressPercent + '%';
      
      document.getElementById('processedCount').textContent = processedCount;
      document.getElementById('translatedCount').textContent = translatedCount;
      document.getElementById('failedCount').textContent = failedCount;
      document.getElementById('cacheHits').textContent = cacheHits;
    }

    // Enhanced Voice Recognition Functions
    function startVoiceRecognitionPhase() {
      console.log('🎤 Starting enhanced voice recognition phase');
      gameState = 'voiceRecognition';
      
      // Reset pronunciation state
      currentPronunciationRound = 1;
      pronunciationResults = [];
      pronunciationStartTime = millis();
      
      // Hide translation input and show voice recognition
      document.getElementById('translationInput').style.display = 'none';
      document.getElementById('voiceRecognition').style.display = 'block';
      
      // Set up the word to practice
      document.getElementById('pronunciationWord').textContent = currentPhrase.english;
      document.getElementById('phoneticDisplay').textContent = currentPhrase.phonetic;
      
      // Reset all rounds to pending
      resetPronunciationRounds();
      
      // Start first round automatically after showing example
      setTimeout(() => {
        playPronunciationExample();
      }, 1000);
    }

    function resetPronunciationRounds() {
      for (let i = 1; i <= 3; i++) {
        const roundEl = document.getElementById(`round${i}`);
        roundEl.className = 'round-card round-pending';
        document.getElementById(`round${i}Status`).textContent = 'Pending';
      }
      updatePronunciationScores(0, 0, 0, 0);
    }

    function playPronunciationExample() {
      showFeedback('🔊 Listen to the correct pronunciation first...', 'info');
      playPronunciation(1.0, () => {
        setTimeout(() => {
          showFeedback('🎤 Now it\'s your turn! Click the microphone to start (relaxed matching enabled).', 'info');
          setActiveRound(1);
        }, 1000);
      });
    }

    function playPronunciation(rate = 1.0, callback = null) {
      if (speechSynthesis) {
        // Stop any ongoing speech
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(currentPhrase.english);
        utterance.lang = 'en-US';
        utterance.rate = rate;
        utterance.pitch = 1;
        utterance.volume = 1;
        
        if (callback) {
          utterance.onend = callback;
        }
         speechSynthesis.speak(utterance);
        console.log(`🔊 Playing pronunciation at rate ${rate}`);
      } else {
        console.warn('⚠️ Speech synthesis not available');
        if (callback) callback();
      }
    }

    function playSlowPronunciation() {
      playPronunciation(0.6);
    }

    function playRepeatPronunciation() {
      let count = 0;
      function playNext() {
        if (count < 3) {
          count++;
          playPronunciation(1.0, () => {
            setTimeout(playNext, 800);
          });
        }
      }
      playNext();
    }

    function setActiveRound(roundNumber) {
      // Reset all rounds
      for (let i = 1; i <= 3; i++) {
        const roundEl = document.getElementById(`round${i}`);
        if (i < roundNumber) {
          // Already completed rounds
          continue;
        } else if (i === roundNumber) {
          roundEl.className = 'round-card round-active';
          document.getElementById(`round${i}Status`).textContent = 'Active';
        } else {
          roundEl.className = 'round-card round-pending';
          document.getElementById(`round${i}Status`).textContent = 'Pending';
        }
      }
      currentPronunciationRound = roundNumber;
    }

    function startRecording() {
      if (!recognition) {
        showFeedback('Enhanced voice recognition not available. Please check microphone permissions.', 'error');
        return;
      }
      
      if (isRecording) {
        recognition.stop();
        return;
      }
      
      try {
        // Resume audio context if suspended
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }
        
        recognition.start();
      } catch (error) {
        console.error('Error starting enhanced recognition:', error);
        showFeedback('Error starting voice recognition. Please try again.', 'error');
      }
    }

    function processPronunciationResult(spokenText, confidence) {
      const targetWord = currentPhrase.english.toLowerCase();
      const similarity = calculateEnhancedSimilarity(spokenText, targetWord);
      
      console.log(`🎯 Target: "${targetWord}", Spoken: "${spokenText}"`);
      console.log(`📊 Enhanced Similarity: ${similarity}%, Confidence: ${(confidence * 100).toFixed(1)}%`);
      
      // Enhanced scoring with relaxed thresholds
      const accuracyScore = similarity;
      const clarityScore = confidence * 100;
      const speedScore = calculateSpeedScore();
      
      // Weighted overall score (favor accuracy and clarity)
      const overallScore = (accuracyScore * 0.5) + (clarityScore * 0.3) + (speedScore * 0.2);
      
      // Store result
      pronunciationResults.push({
        round: currentPronunciationRound,
        spoken: spokenText,
        accuracy: accuracyScore,
        clarity: clarityScore,
        speed: speedScore,
        overall: overallScore
      });
      
      // Update round status with relaxed acceptance criteria
      const roundEl = document.getElementById(`round${currentPronunciationRound}`);
      const statusEl = document.getElementById(`round${currentPronunciationRound}Status`);
      
      if (overallScore >= 50) { // Relaxed from 70% to 50%
        roundEl.className = 'round-card round-success';
        statusEl.textContent = `${overallScore.toFixed(0)}% ✅`;
        showFeedback(`🎉 Great pronunciation! Score: ${overallScore.toFixed(1)}% (Accepted)`, 'success');
      } else if (overallScore >= 30) { // Relaxed from 40% to 30%
        roundEl.className = 'round-card round-success';
        statusEl.textContent = `${overallScore.toFixed(0)}% ⚠️`;
        showFeedback(`🔄 Good attempt! Score: ${overallScore.toFixed(1)}% (Accepted with tolerance)`, 'info');
      } else {
        roundEl.className = 'round-card round-failed';
        statusEl.textContent = `${overallScore.toFixed(0)}% ❌`;
        showFeedback(`🎯 Keep practicing! Score: ${overallScore.toFixed(1)}%. Try speaking more clearly.`, 'error');
      }
      
      // Update scores display
      updatePronunciationScores(accuracyScore, clarityScore, speedScore, overallScore);
      
      // Move to next round or finish - ALL 3 ROUNDS ARE MANDATORY
      if (currentPronunciationRound < 3) {
        setTimeout(() => {
          currentPronunciationRound++;
          setActiveRound(currentPronunciationRound);
          showFeedback(`🎤 Round ${currentPronunciationRound}: Click microphone to continue`, 'info');
        }, 2500);
      } else {
        // All 3 rounds completed
        setTimeout(() => {
          showFeedback(`🎊 All 3 pronunciation rounds completed! Moving to next word...`, 'success');
          setTimeout(() => {
            finishPronunciationPhase();
          }, 1500);
        }, 2000);
      }
    }

    function levenshteinDistance(str1, str2) {
      const matrix = [];
      
      for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
          if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1,
              matrix[i][j - 1] + 1,
              matrix[i - 1][j] + 1
            );
          }
        }
      }
      
      return matrix[str2.length][str1.length];
    }

    function calculateSpeedScore() {
      const elapsedTime = (millis() - pronunciationStartTime) / 1000;
      const targetTime = 3; // 3 seconds is optimal
      
      if (elapsedTime <= targetTime) {
        return 100;
      } else if (elapsedTime <= targetTime * 2) {
        return Math.max(60, 100 - (elapsedTime - targetTime) * 20);
      } else {
        return 40;
      }
    }

    function updatePronunciationScores(accuracy, clarity, speed, overall) {
      document.getElementById('accuracyScore').textContent = `${accuracy.toFixed(0)}%`;
      document.getElementById('clarityScore').textContent = `${clarity.toFixed(0)}%`;
      document.getElementById('speedScore').textContent = `${speed.toFixed(0)}%`;
      document.getElementById('overallScore').textContent = `${overall.toFixed(0)}%`;
    }

    function finishPronunciationPhase() {
      console.log('🏁 Finishing enhanced pronunciation phase');
      
      // Calculate average pronunciation score for this word
      const avgScore = pronunciationResults.reduce((sum, result) => sum + result.overall, 0) / pronunciationResults.length;
      totalPronunciationScore += avgScore;
      
      // Check if pronunciation failed (below 50% threshold)
      const pronunciationFailed = avgScore < 50;
      
      // Find if there's already a translation error for this word
      const existingErrorIndex = errors.findIndex(error => 
        error.word === currentPhrase.english && 
        (error.errorType === 'Translation Error')
      );
      
      if (pronunciationFailed) {
        if (existingErrorIndex !== -1) {
          // Update existing translation error to "Both"
          errors[existingErrorIndex].errorType = 'Both';
        } else {
          // Add new pronunciation error
          errors.push({
            word: currentPhrase.english,
            expected: currentPhrase.spanish.join(' / '),
            userInput: '(correct translation)',
            pronunciation: currentPhrase.pronunciation,
            phonetic: currentPhrase.phonetic,
            errorType: 'Pronunciation Error'
          });
        }
      }
      
      // Hide voice recognition interface
      document.getElementById('voiceRecognition').style.display = 'none';
      
      // Show results summary
      showFeedback(`🎯 Pronunciation complete! Average score: ${avgScore.toFixed(1)}%`, 'success');
      
      // Continue to next round
      setTimeout(() => {
        nextRound();
      }, 2000);
    }

    function updateMicButton() {
      const micButton = document.getElementById('micButton');
      if (isRecording) {
        micButton.className = 'mic-button recording';
        micButton.innerHTML = '🔴<div class="mic-volume-indicator" id="volumeIndicator" style="display: flex;">📊</div>';
        micButton.title = 'Recording with amplification... Click to stop';
      } else {
        micButton.className = 'mic-button';
        micButton.innerHTML = '🎤<div class="mic-volume-indicator" id="volumeIndicator">📊</div>';
        micButton.title = 'Click to start enhanced recording';
      }
    }

    function showVoiceWave() {
      document.getElementById('voiceWave').style.display = 'flex';
    }

    function hideVoiceWave() {
      document.getElementById('voiceWave').style.display = 'none';
    }

    function showFeedback(message, type) {
      const feedbackEl = document.getElementById('voiceFeedback');
      feedbackEl.innerHTML = `<div class="voice-feedback feedback-${type}">${message}</div>`;
      
      // Auto-clear success and info messages after 5 seconds
      if (type === 'success' || type === 'info') {
        setTimeout(() => {
          if (feedbackEl.innerHTML.includes(message)) {
            feedbackEl.innerHTML = '';
          }
        }, 5000);
      }
    }

    // File handling functions
    async function handleFile(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      if (!file.name.endsWith('.txt')) {
        alert('📄 Please upload a .txt file.');
        return;
      }
      
      console.log(`📁 Processing file: ${file.name} (${file.size} bytes)`);
      
      processingWords = true;
      processedCount = 0;
      translatedCount = 0;
      failedCount = 0;
      cacheHits = 0;
      phrases = [];
      
      document.getElementById('loadingContainer').style.display = 'block';
      document.getElementById('wordStats').style.display = 'block';
      document.getElementById('loadingText').innerHTML = '<span class="processing-indicator"></span>Reading and analyzing file...';
      
      const reader = new FileReader();
      reader.onload = async (e) => {
        const content = e.target.result;
        console.log(`📖 File content length: ${content.length} characters`);
        
        const analysis = analyzeText(content);
        displayFileAnalysis(analysis);
        
        const items = extractWordsAndSentences(content);
        totalWords = items.length;
        
        console.log(`🔍 Extracted ${totalWords} items for processing`);
        
        if (totalWords === 0) {
          alert('❌ No valid words or sentences found in the file.');
          processingWords = false;
          return;
        }
        
        document.getElementById('progressText').textContent = `Processing ${totalWords} items...`;
        
        await processAllItems(items);
      };
      
      reader.onerror = () => {
        alert('❌ Error reading file. Please try again.');
        processingWords = false;
      };
      
      reader.readAsText(file);
    }

    function analyzeText(content) {
      const words = content.toLowerCase().match(/\b[a-z]+\b/g) || [];
      const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
      const characters = content.length;
      const uniqueWords = [...new Set(words)];
      
      return {
        totalWords: words.length,
        uniqueWords: uniqueWords.length,
        sentences: sentences.length,
        characters: characters
      };
    }

    function displayFileAnalysis(analysis) {
      document.getElementById('fileInfo').style.display = 'block';
      document.getElementById('totalWordsCount').textContent = analysis.totalWords;
      document.getElementById('uniqueWordsCount').textContent = analysis.uniqueWords;
      document.getElementById('sentencesCount').textContent = analysis.sentences;
      document.getElementById('charactersCount').textContent = analysis.characters;
      
      console.log('📊 File Analysis:', analysis);
    }

    function extractWordsAndSentences(content) {
      const items = [];
      
      const words = content.toLowerCase().match(/\b[a-z]+\b/g) || [];
      const uniqueWords = [...new Set(words)];
      
      const sentences = content.split(/[.!?]+/)
        .map(s => s.trim().toLowerCase())
        .filter(s => s.length > 0 && s.length < 100)
        .filter(s => s.split(' ').length >= 2);
      
      uniqueWords.forEach(word => {
        if (word.length > 1) {
          items.push({
            type: 'word',
            text: word,
            original: word
          });
        }
      });
      
      sentences.forEach(sentence => {
        items.push({
          type: 'sentence',
          text: sentence,
          original: sentence
        });
      });
      
      console.log(`📝 Extracted: ${uniqueWords.length} words + ${sentences.length} sentences = ${items.length} total items`);
      return items;
    }

    async function processAllItems(items) {
      phrases = [];
      
      document.getElementById('progressText').textContent = 'Processing with comprehensive dictionary...';
      
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        let translations = null;
        
        try {
          if (translationDictionary[item.text]) {
            translations = translationDictionary[item.text];
            cacheHits++;
          } else if (translationCache[item.text]) {
            translations = translationCache[item.text];
            cacheHits++;
          } else if (item.type === 'sentence') {
            translations = translateSentence(item.text);
          } else {
            translations = findSimilarTranslation(item.text);
          }
          
          if (translations && translations.length > 0) {
            phrases.push({
              english: item.text,
              spanish: translations.map(normalizeText),
              pronunciation: `/Generated/`,
              phonetic: generatePhonetic(item.text),
              type: item.type
            });
            
            translationCache[item.text] = translations;
            translatedCount++;
          } else {
            phrases.push({
              english: item.text,
              spanish: [item.text],
              pronunciation: `/Unknown/`,
              phonetic: generatePhonetic(item.text),
              type: item.type
            });
            failedCount++;
          }
        } catch (error) {
          console.warn(`Error processing "${item.text}":`, error);
          failedCount++;
        }
        
        processedCount++;
        updateProgressBar(processedCount / totalWords);
        
        if (processedCount % 50 === 0) {
          document.getElementById('progressText').textContent = 
            `Processed ${processedCount}/${totalWords} items...`;
        }
        
        if (i % 100 === 0) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      
      processingWords = false;
      fileLoaded = true;
      
      document.getElementById('loadingText').innerHTML = 
        `<span style="color: #4ecdc4;">✅ Processing Complete!</span>`;
      document.getElementById('progressText').textContent = 
        `Successfully processed ${phrases.length} items`;
      
      setTimeout(() => {
        document.getElementById('loadingContainer').style.display = 'none';
        updateUI();
      }, 2000);
      
      console.log(`✅ Processing complete: ${phrases.length}/${totalWords} items processed successfully`);
    }

    function translateSentence(sentence) {
      const words = sentence.split(' ');
      const translatedWords = [];
      
      for (let word of words) {
        if (translationDictionary[word]) {
          translatedWords.push(translationDictionary[word][0]);
        } else {
          translatedWords.push(word);
        }
      }
      
      return [translatedWords.join(' ')];
    }

    function findSimilarTranslation(word) {
      const keys = Object.keys(translationDictionary);
      
      for (let key of keys) {
        if (key.includes(word) || word.includes(key)) {
          return translationDictionary[key];
        }
      }
      
      if (word.length > 3) {
        const ending = word.slice(-3);
        for (let key of keys) {
          if (key.endsWith(ending) && key.length > 3) {
            return translationDictionary[key];
          }
        }
      }
      
      return null;
    }

    function startPlaying() {
      console.log('🎮 Starting enhanced game...');
      
      if (phrases.length === 0) {
        alert('❌ No words available. Please wait for words to load or upload a file.');
        return;
      }
      
      const roundSizeSelection = document.getElementById('roundSizeSelect').value;
      console.log(`📊 Round size selection: ${roundSizeSelection}`);
      
      if (roundSizeSelection === '25') {
        roundSize = Math.min(25, phrases.length);
      } else if (roundSizeSelection === '50') {
        roundSize = Math.min(50, phrases.length);
      } else if (roundSizeSelection === '100') {
        roundSize = Math.min(100, phrases.length);
      } else if (roundSizeSelection === 'half') {
        roundSize = Math.floor(phrases.length / 2);
      } else {
        roundSize = phrases.length;
      }
      
      console.log(`🎯 Starting game with ${roundSize} words out of ${phrases.length} available`);
      
      resetGameState();
      currentRoundWords = shuffleArray(phrases).slice(0, roundSize);
      
      gameState = 'countdown';
      countdownTimer = millis();
      startTime = millis();
      
      hideControls();
      showGameElements();
    }

    function resetGameState() {
      score = 0;
      correctAnswers = 0;
      incorrectTranslations = 0;
      round = 0;
      errors = [];
      currentPhraseIndex = 0;
      waitingForPronunciation = false;
      pronunciationAttempts = 0;
      totalPronunciationScore = 0;
    }

    function hideControls() {
      document.getElementById('controlsPanel').style.display = 'none';
      document.getElementById('startButton').style.display = 'none';
      document.getElementById('finalStats').style.display = 'none';
      document.getElementById('errorsReview').style.display = 'none';
      document.getElementById('fileInfo').style.display = 'none';
    }

    function showGameElements() {
      document.getElementById('gameInfo').style.display = 'block';
    }

    function startMainGame() {
      gameState = 'playing';
      timeLeft = difficultyTimes[document.getElementById('typeSelect').value];
      currentPhraseIndex = 0;
      selectNewPhrase();
      
      document.getElementById('translationInput').style.display = 'block';
      document.getElementById('inputTranslation').focus();
    }

    function selectNewPhrase() {
      if (currentPhraseIndex < currentRoundWords.length) {
        currentPhrase = currentRoundWords[currentPhraseIndex];
      } else {
        currentPhrase = null;
      }
    }

    function submit() {
      if (gameState !== 'playing') return;
      if (!currentPhrase) return;
      
      const input = normalizeText(document.getElementById('inputTranslation').value);
      const correctAnswers_local = currentPhrase.spanish;
      const isCorrect = correctAnswers_local.includes(input);
      
      if (isCorrect) {
        score += Math.max(10, Math.floor(timeLeft * 2));
        correctAnswers++;
        showCorrectFeedback();
      } else {
        incorrectTranslations++;
        errors.push({
          word: currentPhrase.english,
          expected: currentPhrase.spanish.join(' / '),
          userInput: input,
          pronunciation: currentPhrase.pronunciation,
          phonetic: currentPhrase.phonetic,
          errorType: 'Translation Error'
        });
        showIncorrectFeedback();
      }
      
      document.getElementById('inputTranslation').value = '';
      
      // Start enhanced voice recognition phase
      startVoiceRecognitionPhase();
    }

    function handleTimeout() {
      incorrectTranslations++;
      if (currentPhrase) {
        errors.push({
          word: currentPhrase.english,
          expected: currentPhrase.spanish.join(' / '),
          userInput: '(timeout)',
          pronunciation: currentPhrase.pronunciation,
          phonetic: currentPhrase.phonetic,
          errorType: 'Translation Error'
        });
      }
      showTimeoutFeedback();
      startVoiceRecognitionPhase();
    }

    function nextRound() {
      round++;
      currentPhraseIndex++;
      
      if (round >= roundSize || currentPhraseIndex >= currentRoundWords.length) {
        finishGame();
      } else {
        selectNewPhrase();
        resetTimer();
        
        gameState = 'playing';
        document.getElementById('translationInput').style.display = 'block';
        document.getElementById('inputTranslation').focus();
      }
    }

    function finishGame() {
      totalGameTime = (millis() - startTime) / 1000;
      
      if (errors.length > 0) {
        showErrorReview();
      } else {
        gameState = 'finalResults';
        showFinalResults();
      }
    }

    function showErrorReview() {
      gameState = 'errorReview';
      
      document.getElementById('gameInfo').style.display = 'none';
      document.getElementById('translationInput').style.display = 'none';
      document.getElementById('voiceRecognition').style.display = 'none';
      document.getElementById('errorsReview').style.display = 'block';
      
      const errorsList = document.getElementById('errorsList');
      errorsList.innerHTML = '';
      
      errors.forEach((error, index) => {
        const errorItem = document.createElement('div');
        errorItem.style.cssText = `
          background: rgba(255, 255, 255, 0.05);
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 10px;
          padding: 15px;
          margin: 10px 0;
          text-align: left;
        `;
        errorItem.innerHTML = `
          <div style="color: #ffd700; font-size: 1.2rem; font-weight: 600; margin-bottom: 8px;">
            ${index + 1}. "${error.word}"
          </div>
          <div style="color: rgba(255, 255, 255, 0.9); font-size: 0.95rem; line-height: 1.4;">
            <div style="color: #ff9800; font-weight: 600; margin-bottom: 5px;">🏷️ Error Type: ${error.errorType}</div>
            <div>✅ <span style="color: #4ecdc4; font-weight: 500;">Correct: ${error.expected}</span></div>
            <div>❌ <span style="color: #ff6b6b; font-weight: 500;">Your answer: ${error.userInput}</span></div>
            <div>🔊 <span style="color: #4ecdc4; font-weight: 500;">Pronunciation: ${error.phonetic}</span></div>
          </div>
        `;
        errorsList.appendChild(errorItem);
      });
    }

    function startRetryRound() {
      resetGameState();
      gameState = 'countdown';
      countdownTimer = millis();
      startTime = millis();
      
      document.getElementById('errorsReview').style.display = 'none';
      showGameElements();
    }

    function showFinalResults() {
      document.getElementById('gameInfo').style.display = 'none';
      document.getElementById('translationInput').style.display = 'none';
      document.getElementById('voiceRecognition').style.display = 'none';
      document.getElementById('errorsReview').style.display = 'none';
      
      gameState = 'finalResults';
      
      setTimeout(() => {
        document.getElementById('controlsPanel').style.display = 'flex';
        document.getElementById('startButton').style.display = 'block';
        document.getElementById('fileInfo').style.display = 'block';
      }, 3000);
    }

    function resetTimer() {
      timeLeft = difficultyTimes[document.getElementById('typeSelect').value];
      document.getElementById('inputTranslation').focus();
    }

    function showCorrectFeedback() {
      const input = document.getElementById('inputTranslation');
      input.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
      input.style.borderColor = '#4CAF50';
      
      setTimeout(() => {
        input.style.backgroundColor = '';
        input.style.borderColor = '';
      }, 1000);
    }

    function showIncorrectFeedback() {
      const input = document.getElementById('inputTranslation');
      input.style.backgroundColor = 'rgba(244, 67, 54, 0.3)';
      input.style.borderColor = '#F44336';
      input.style.animation = 'shake 0.5s ease-in-out';
      
      setTimeout(() => {
        input.style.backgroundColor = '';
        input.style.borderColor = '';
        input.style.animation = 'none';
      }, 1000);
    }

    function showTimeoutFeedback() {
      const timer = document.getElementById('timerDisplay');
      const originalBg = timer.style.backgroundColor;
      timer.style.backgroundColor = 'rgba(244, 67, 54, 0.5)';
      timer.style.animation = 'shake 0.5s ease-in-out';
      
      setTimeout(() => {
        timer.style.backgroundColor = originalBg;
        timer.style.animation = 'none';
      }, 1000);
    }

    function getCurrentUser() {
      return 'GerarAbdiel';
    }

    function getCurrentDateTime() {
      return '2025-06-20 23:37:03';
    }

    // Event listeners
    document.getElementById('startButton').addEventListener('click', startPlaying);
    document.getElementById('submitButton').addEventListener('click', submit);
    document.getElementById('micButton').addEventListener('click', startRecording);
    document.getElementById('playPronunciation').addEventListener('click', () => playPronunciation(1.0));
    document.getElementById('playSlowPronunciation').addEventListener('click', playSlowPronunciation);
    document.getElementById('repeatPronunciation').addEventListener('click', playRepeatPronunciation);
    document.getElementById('retryButton').addEventListener('click', startRetryRound);

    document.getElementById('inputTranslation').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        submit();
      }
    });

    document.getElementById('inputTranslation').addEventListener('input', function() {
      const submitBtn = document.getElementById('submitButton');
      submitBtn.disabled = this.value.trim() === '';
    });

    document.addEventListener('keydown', function(e) {
      if (gameState === 'voiceRecognition' && e.key === ' ') {
        e.preventDefault();
        startRecording();
      }
    });

    // Initialize enhanced game
    window.addEventListener('load', function() {
      console.log('🎮 Translate Blitz Pro - Enhanced Voice loaded successfully!');
      console.log(`📚 Dictionary with ${Object.keys(translationDictionary).length} entries ready!`);
      console.log(`👋 Welcome, ${getCurrentUser()}!`);
      console.log(`📅 Current Date: ${getCurrentDateTime()}`);
      console.log('🎤 Enhanced voice recognition with amplification initialized');
      console.log('🔊 Relaxed pronunciation matching enabled (50%+ acceptance)');
      console.log('🎵 Unlimited audio repetition available');
      
      // Load default words if not already loaded (fallback for p5.js setup)
      if (phrases.length === 0) {
        console.log('📚 Loading default words from window load event...');
        loadDefaultWords();
      }
    });
  </script>
</body>
</html>
