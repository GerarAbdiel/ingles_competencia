<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Translate Blitz: A comprehensive English-to-Spanish translation game with enhanced voice recognition.">
  <title>Translate Blitz Pro - Enhanced Voice</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      overflow-x: hidden;
    }

    .game-container {
      max-width: 900px;
      width: 100%;
      text-align: center;
    }

    .game-header {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 30px;
      margin-bottom: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .game-title {
      font-size: 3rem;
      font-weight: 700;
      color: #ffd700;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      margin-bottom: 10px;
    }

    .game-subtitle {
      font-size: 1.2rem;
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 20px;
    }

    canvas {
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(5px);
    }

    .controls-panel {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      padding: 25px;
      margin: 20px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      justify-content: center;
      align-items: center;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .input-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 0.9rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    input, select, button {
      padding: 12px 18px;
      font-size: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      color: #fff;
      transition: all 0.3s ease;
      min-width: 200px;
    }

    input::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }

    input:focus, select:focus {
      outline: none;
      border-color: #ffd700;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      background: rgba(255, 255, 255, 0.2);
    }

    button {
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
      border: none;
      color: white;
      font-weight: 600;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
    }

    .start-button {
      background: linear-gradient(45deg, #56ab2f, #a8e6cf);
      font-size: 1.1rem;
      padding: 15px 30px;
      border-radius: 25px;
    }

    .loading-container {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      margin: 15px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .loading-text {
      color: rgba(255, 255, 255, 0.9);
      font-size: 1.1rem;
      font-weight: 500;
      margin-bottom: 15px;
    }

    .progress-container {
      width: 100%;
      max-width: 500px;
      margin: 15px auto;
    }

    .progress-bar {
      width: 100%;
      height: 12px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 10px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #ffd700, #ffed4e);
      border-radius: 6px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .progress-stats {
      display: flex;
      justify-content: space-between;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.9rem;
    }

    .word-stats {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 15px;
      margin: 10px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      margin-top: 10px;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }

    .stat-number {
      font-size: 1.5rem;
      font-weight: 700;
      color: #ffd700;
      display: block;
    }

    .stat-label {
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.8rem;
      text-transform: uppercase;
    }

    .file-info {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 15px;
      margin: 10px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .game-info {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 15px;
      margin: 10px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .current-word {
      font-size: 2.5rem;
      font-weight: 700;
      color: #ffd700;
      margin: 20px 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .timer-display {
      font-size: 1.8rem;
      font-weight: 600;
      padding: 10px 20px;
      border-radius: 25px;
      background: rgba(255, 255, 255, 0.1);
      display: inline-block;
      margin: 10px 0;
      color: #4ecdc4;
      border: 2px solid #4ecdc4;
    }

    .translation-input {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      margin: 15px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .voice-recognition {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 25px;
      margin: 15px 0;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
    }

    .voice-title {
      font-size: 1.5rem;
      color: #ffa726;
      font-weight: 600;
      margin-bottom: 20px;
    }

    .pronunciation-audio {
      background: rgba(255, 167, 38, 0.2);
      border: 1px solid #ffa726;
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
    }

    .pronunciation-controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 15px 0;
      flex-wrap: wrap;
    }

    .play-button {
      background: linear-gradient(45deg, #ffa726, #ff7043);
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      font-size: 1.5rem;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .play-button:hover {
      transform: scale(1.1);
    }

    .pronunciation-rounds {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin: 20px 0;
    }

    .round-card {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      border: 2px solid transparent;
      transition: all 0.3s ease;
    }

    .round-pending {
      border-color: rgba(255, 255, 255, 0.3);
      color: rgba(255, 255, 255, 0.7);
    }

    .round-active {
      border-color: #ffa726;
      background: rgba(255, 167, 38, 0.2);
      color: #ffa726;
      animation: pulse 1s ease-in-out infinite;
    }

    .round-success {
      border-color: #4ecdc4;
      background: rgba(78, 205, 196, 0.2);
      color: #4ecdc4;
    }

    .round-failed {
      border-color: #ff6b6b;
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
    }

    .mic-button {
      background: linear-gradient(45deg, #ff6b6b, #ffa726);
      border: none;
      border-radius: 50%;
      width: 100px;
      height: 100px;
      font-size: 2.5rem;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 20px auto;
      display: block;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    .mic-button:hover {
      transform: scale(1.05);
    }

    .mic-button.recording {
      background: linear-gradient(45deg, #ff4757, #ff3838);
      animation: recording 1s ease-in-out infinite;
      box-shadow: 0 0 30px rgba(255, 71, 87, 0.6);
    }

    .mic-volume-indicator {
      position: absolute;
      top: -10px;
      right: -10px;
      background: #4ecdc4;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      animation: pulse 0.5s ease-in-out infinite;
    }

    .voice-feedback {
      margin: 15px 0;
      padding: 15px;
      border-radius: 10px;
      font-size: 1.1rem;
      font-weight: 500;
    }

    .feedback-success {
      background: rgba(78, 205, 196, 0.2);
      border: 1px solid #4ecdc4;
      color: #4ecdc4;
    }

    .feedback-error {
      background: rgba(255, 107, 107, 0.2);
      border: 1px solid #ff6b6b;
      color: #ff6b6b;
    }

    .feedback-info {
      background: rgba(255, 167, 38, 0.2);
      border: 1px solid #ffa726;
      color: #ffa726;
    }

    .pronunciation-score {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
      margin: 20px 0;
    }

    .score-item {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 10px;
      text-align: center;
    }

    .score-value {
      font-size: 1.2rem;
      font-weight: 700;
      color: #ffd700;
      display: block;
    }

    .score-label {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.8);
      text-transform: uppercase;
    }

    .voice-wave {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 3px;
      margin: 15px 0;
    }

    .wave-bar {
      width: 4px;
      height: 20px;
      background: #ffa726;
      border-radius: 2px;
      animation: wave 1.5s ease-in-out infinite;
    }

    .wave-bar:nth-child(2) { animation-delay: 0.1s; }
    .wave-bar:nth-child(3) { animation-delay: 0.2s; }
    .wave-bar:nth-child(4) { animation-delay: 0.3s; }
    .wave-bar:nth-child(5) { animation-delay: 0.4s; }

    .microphone-setup {
      background: rgba(255, 167, 38, 0.1);
      border: 1px solid #ffa726;
      border-radius: 10px;
      padding: 15px;
      margin: 15px 0;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.9);
    }

    .errors-review {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      padding: 25px;
      margin: 20px 0;
      max-width: 800px;
      width: 100%;
      display: none;
    }

    .error-type-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 0.85rem;
      font-weight: 600;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .error-translation {
      background: rgba(255, 107, 107, 0.2);
      color: #ff6b6b;
      border: 1px solid #ff6b6b;
    }

    .error-pronunciation {
      background: rgba(255, 167, 38, 0.2);
      color: #ffa726;
      border: 1px solid #ffa726;
    }

    .error-both {
      background: rgba(255, 71, 87, 0.2);
      color: #ff4757;
      border: 1px solid #ff4757;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    @keyframes recording {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255, 71, 87, 0.6); }
      50% { transform: scale(1.1); box-shadow: 0 0 50px rgba(255, 71, 87, 0.9); }
    }

    @keyframes wave {
      0%, 100% { height: 20px; }
      50% { height: 40px; }
    }

    .processing-indicator {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top: 3px solid #ffd700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }

    .download-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
    }

    .download-button:active {
      transform: translateY(0);
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    @media (max-width: 768px) {
      .game-title {
        font-size: 2rem;
      }
      
      .controls-panel {
        flex-direction: column;
        padding: 20px;
      }
      
      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .pronunciation-rounds {
        grid-template-columns: 1fr;
        gap: 10px;
      }
      
      .mic-button {
        width: 80px;
        height: 80px;
        font-size: 2rem;
      }
      
      canvas {
        width: 100% !important;
        height: auto !important;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="game-header">
      <h1 class="game-title">üåü Translate Blitz Pro</h1>
      <p class="game-subtitle">Enhanced Voice Recognition & Pronunciation Training</p>
    </div>

    <div class="controls-panel" id="controlsPanel">
      <div class="input-group">
        <label class="input-label">üìÅ Upload Vocabulary File</label>
        <input type="file" id="fileInput" accept=".txt">
      </div>
      
      <div class="input-group">
        <label class="input-label">‚ö° Difficulty</label>
        <select id="typeSelect">
          <option value="easy">üêå Easy (15s per word)</option>
          <option value="medium">üöÄ Medium (8s per word)</option>
          <option value="hard">‚ö° Hard (3s per word)</option>
        </select>
      </div>
      
      <div class="input-group">
        <label class="input-label">üìä Round Size</label>
        <select id="roundSizeSelect">
          <option value="25">25 Words</option>
          <option value="50">50 Words</option>
          <option value="100">100 Words</option>
          <option value="half">Half Collection</option>
          <option value="all">All Words</option>
        </select>
      </div>
    </div>

    <!-- Offline AI Info -->
    <div class="offline-info" id="offlineInfo" style="background: rgba(76, 175, 80, 0.1); border: 2px solid #4caf50; border-radius: 15px; padding: 20px; margin: 20px 0; text-align: center;">
      <h3 style="color: #4caf50; margin: 0 0 15px 0;">ü§ñ Sistema de IA Offline Activado</h3>
      <p style="color: #fff; margin: 10px 0; line-height: 1.6;">
        Este juego usa un <strong>sistema de IA offline avanzado</strong> que funciona completamente en tu navegador.<br>
        ‚úÖ <strong>An√°lisis sem√°ntico local</strong> ‚Ä¢ ‚úÖ <strong>Validaci√≥n de sin√≥nimos</strong> ‚Ä¢ ‚úÖ <strong>An√°lisis fon√©tico</strong>
      </p>
      <div style="font-size: 12px; color: #a5d6a7; margin-top: 10px;">
        Sin necesidad de conexi√≥n a internet para las funciones de IA
      </div>
    </div>

    <div class="file-info" id="fileInfo">
      <h3 style="color: #ffd700; margin-bottom: 10px;">üìÑ File Analysis</h3>
      <div class="stats-grid">
        <div class="stat-card">
          <span class="stat-number" id="totalWordsCount">0</span>
          <span class="stat-label">Total Words</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="uniqueWordsCount">0</span>
          <span class="stat-label">Unique Words</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="sentencesCount">0</span>
          <span class="stat-label">Sentences</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="charactersCount">0</span>
          <span class="stat-label">Characters</span>
        </div>
      </div>
    </div>

    <div class="loading-container" id="loadingContainer">
      <div class="loading-text" id="loadingText">
        <span class="processing-indicator"></span>
        Processing vocabulary with comprehensive translation...
      </div>
      
      <div class="progress-container">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-stats">
          <span id="progressText">Initializing...</span>
          <span id="progressPercent">0%</span>
        </div>
      </div>

      <div class="word-stats" id="wordStats">
        <div class="stats-grid">
          <div class="stat-card">
            <span class="stat-number" id="processedCount">0</span>
            <span class="stat-label">Processed</span>
          </div>
          <div class="stat-card">
            <span class="stat-number" id="translatedCount">0</span>
            <span class="stat-label">Translated</span>
          </div>
          <div class="stat-card">
            <span class="stat-number" id="failedCount">0</span>
            <span class="stat-label">Failed</span>
          </div>
          <div class="stat-card">
            <span class="stat-number" id="cacheHits">0</span>
            <span class="stat-label">Cache Hits</span>
          </div>
        </div>
      </div>
    </div>

    <button class="start-button" id="startButton">
      üöÄ Start Game
    </button>

    <div class="game-info" id="gameInfo">
      <div class="current-word" id="currentWordDisplay"></div>
      <div class="timer-display" id="timerDisplay"></div>
      <div class="stats-grid">
        <div class="stat-card">
          <span class="stat-number" id="scoreDisplay">0</span>
          <span class="stat-label">Score</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="correctDisplay">0</span>
          <span class="stat-label">Correct</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="incorrectDisplay">0</span>
          <span class="stat-label">Incorrect</span>
        </div>
        <div class="stat-card">
          <span class="stat-number" id="roundDisplay">0/0</span>
          <span class="stat-label">Progress</span>
        </div>
      </div>
    </div>

    <div class="translation-input" id="translationInput">
      <div style="color: rgba(255, 255, 255, 0.9); font-size: 1.1rem; margin-bottom: 15px;">Type your Spanish translation:</div>
      <input type="text" id="inputTranslation" placeholder="Enter Spanish translation..." autocomplete="off">
      <button style="background: linear-gradient(45deg, #667eea, #764ba2); min-width: 150px; margin-top: 10px;" id="submitButton">
        ‚úÖ Submit Answer
      </button>
      <div id="translationFeedback"></div>
      <button style="background: linear-gradient(45deg, #4ecdc4, #44a08d); min-width: 200px; margin-top: 15px; display: none;" id="continueButton">
        ‚û°Ô∏è Continuar al siguiente paso
      </button>
    </div>

    <div class="voice-recognition" id="voiceRecognition">
      <div class="voice-title">üé§ Enhanced Voice Pronunciation Practice</div>
      <div style="color: rgba(255, 255, 255, 0.9); margin-bottom: 20px; font-size: 1.1rem; text-align: center;">
        Practice pronouncing: "<span id="pronunciationWord" style="color: #ffd700; font-weight: 600; font-size: 1.3rem;"></span>"
      </div>

      <div class="pronunciation-audio">
        <div style="color: #ffa726; font-weight: 600; margin-bottom: 15px; text-align: center;">
          üîä Listen to the correct pronunciation (click as many times as needed):
        </div>
        <div class="pronunciation-controls">
          <button class="play-button" id="playPronunciation" title="Play pronunciation">
            ‚ñ∂Ô∏è
          </button>
          <button class="play-button" id="playSlowPronunciation" title="Play slow pronunciation">
            üêå
          </button>
          <button class="play-button" id="repeatPronunciation" title="Repeat 3 times">
            üîÑ
          </button>
        </div>
        <div style="text-align: center; color: rgba(255, 255, 255, 0.8); font-size: 0.9rem; margin-top: 10px;">
          Phonetic: <span id="phoneticDisplay" style="font-family: monospace; color: #ffa726;"></span>
        </div>
      </div>

      <div class="microphone-setup">
        <div style="font-weight: 600; margin-bottom: 10px; color: #ffa726;">üé§ Microphone Enhanced for Better Detection:</div>
        <div style="font-size: 0.85rem; line-height: 1.4;">
          ‚Ä¢ Automatic gain control enabled<br>
          ‚Ä¢ Noise reduction active<br>
          ‚Ä¢ Pronunciation tolerance: Relaxed (50%+ similarity accepted)<br>
          ‚Ä¢ Speak clearly and at normal volume
        </div>
      </div>

      <div class="pronunciation-rounds" id="pronunciationRounds">
        <div class="round-card round-pending" id="round1">
          <div style="font-size: 1.5rem; margin-bottom: 5px;">üéØ</div>
          <div style="font-weight: 600;">Round 1</div>
          <div style="font-size: 0.8rem; margin-top: 5px;" id="round1Status">Pending</div>
        </div>
        <div class="round-card round-pending" id="round2">
          <div style="font-size: 1.5rem; margin-bottom: 5px;">üéØ</div>
          <div style="font-weight: 600;">Round 2</div>
          <div style="font-size: 0.8rem; margin-top: 5px;" id="round2Status">Pending</div>
        </div>
        <div class="round-card round-pending" id="round3">
          <div style="font-size: 1.5rem; margin-bottom: 5px;">üéØ</div>
          <div style="font-weight: 600;">Round 3</div>
          <div style="font-size: 0.8rem; margin-top: 5px;" id="round3Status">Pending</div>
        </div>
      </div>

      <button class="mic-button" id="micButton" title="Click to start recording">
        üé§
        <div class="mic-volume-indicator" id="volumeIndicator">üìä</div>
      </button>

      <div class="voice-wave" id="voiceWave" style="display: none;">
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
        <div class="wave-bar"></div>
      </div>

      <div id="voiceFeedback"></div>

      <div class="pronunciation-score" id="pronunciationScore">
        <div class="score-item">
          <span class="score-value" id="accuracyScore">0%</span>
          <span class="score-label">Precisi√≥n</span>
        </div>
        <div class="score-item">
          <span class="score-value" id="clarityScore">0%</span>
          <span class="score-label">Claridad</span>
        </div>
        <div class="score-item">
          <span class="score-value" id="phoneticScore">0%</span>
          <span class="score-label">Fon√©tica</span>
        </div>
        <div class="score-item">
          <span class="score-value" id="speedScore">0%</span>
          <span class="score-label">Velocidad</span>
        </div>
        <div class="score-item">
          <span class="score-value" id="overallScore">0%</span>
          <span class="score-label">General</span>
        </div>
      </div>
    </div>

    <div class="errors-review" id="errorsReview">
      <h2 style="color: #ff6b6b; font-size: 1.5rem; font-weight: 600; margin-bottom: 20px; text-align: center;">üìù Review Your Mistakes</h2>
      <div id="errorsList"></div>
      <button class="start-button" id="retryButton">
        üîÑ Practice Again
      </button>
    </div>

    <div class="stats-grid" id="finalStats" style="display: none; margin: 20px 0;">
      <div class="stat-card">
        <span class="stat-number" id="finalScore">0</span>
        <span class="stat-label">Final Score</span>
      </div>
      <div class="stat-card">
        <span class="stat-number" id="finalAccuracy">0%</span>
        <span class="stat-label">Translation</span>
      </div>
      <div class="stat-card">
        <span class="stat-number" id="finalTime">0s</span>
        <span class="stat-label">Avg Time</span>
      </div>
      <div class="stat-card">
        <span class="stat-number" id="pronunciationAccuracy">0%</span>
        <span class="stat-label">Pronunciation</span>
      </div>
    </div>
  </div>

  <script>
    // Game state variables
    let phrases = [];
    let currentPhrase = null;
    let score = 0;
    let correctAnswers = 0;
    let incorrectTranslations = 0;
    let timeLeft = 15;
    let gameState = 'waiting';
    let round = 0;
    let roundSize = 25;
    let errors = [];
    let currentPhraseIndex = 0;
    let fileLoaded = false;
    let difficultyTimes = { easy: 15, medium: 8, hard: 3 };
    let particles = [];
    let color1, color2;
    let countdownTimer = 0;
    let processingWords = false;
    let processedCount = 0;
    let translatedCount = 0;
    let failedCount = 0;
    let cacheHits = 0;
    let totalWords = 0;
    let startTime = 0;
    let totalGameTime = 0;
    let currentRoundWords = [];
    let waitingForPronunciation = false;
    let pronunciationAttempts = 0;
    let maxPronunciationAttempts = 3;
    let translationCache = {};

    // OpenRouter AI Integration
    // AI Configuration - DISABLED for offline mode
    const USE_AI = false; // Set to false for offline mode
    const OPENROUTER_API_KEY = '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';
    const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
    let aiCache = new Map();

    // Enhanced voice recognition variables
    let recognition = null;
    let isRecording = false;
    let currentPronunciationRound = 1;
    let pronunciationResults = [];
    let speechSynthesis = window.speechSynthesis;
    let totalPronunciationScore = 0;
    let pronunciationStartTime = 0;
    let audioContext = null;
    let mediaStream = null;
    let analyser = null;
    let microphone = null;
    let gainNode = null;
    let timerPaused = false;

    // Enhanced translation dictionary
    const translationDictionary = {
      'hello': ['hola'], 'hi': ['hola'], 'goodbye': ['adi√≥s'], 'bye': ['adi√≥s'], 
      'please': ['por favor'], 'thank you': ['gracias'], 'thanks': ['gracias'], 
      'sorry': ['lo siento'], 'excuse me': ['disculpe'], 'yes': ['s√≠'], 'no': ['no'],
      'time': ['tiempo', 'hora'], 'day': ['d√≠a'], 'night': ['noche'], 'morning': ['ma√±ana'], 
      'afternoon': ['tarde'], 'evening': ['noche'], 'today': ['hoy'], 'yesterday': ['ayer'], 
      'tomorrow': ['ma√±ana'], 'week': ['semana'], 'month': ['mes'], 'year': ['a√±o'],
      'one': ['uno'], 'two': ['dos'], 'three': ['tres'], 'four': ['cuatro'], 'five': ['cinco'],
      'six': ['seis'], 'seven': ['siete'], 'eight': ['ocho'], 'nine': ['nueve'], 'ten': ['diez'],
      'red': ['rojo'], 'blue': ['azul'], 'green': ['verde'], 'yellow': ['amarillo'], 
      'orange': ['naranja'], 'purple': ['morado'], 'pink': ['rosa'], 'brown': ['marr√≥n'], 
      'black': ['negro'], 'white': ['blanco'], 'gray': ['gris'], 'grey': ['gris'],
      'family': ['familia'], 'mother': ['madre'], 'father': ['padre'], 'mom': ['mam√°'], 
      'dad': ['pap√°'], 'sister': ['hermana'], 'brother': ['hermano'], 'son': ['hijo'], 
      'daughter': ['hija'], 'friend': ['amigo'], 'person': ['persona'], 'people': ['gente'],
      'head': ['cabeza'], 'face': ['cara'], 'eye': ['ojo'], 'nose': ['nariz'], 'mouth': ['boca'],
      'hand': ['mano'], 'arm': ['brazo'], 'leg': ['pierna'], 'foot': ['pie'], 'heart': ['coraz√≥n'],
      'dog': ['perro'], 'cat': ['gato'], 'bird': ['p√°jaro'], 'fish': ['pez'], 'horse': ['caballo'],
      'food': ['comida'], 'water': ['agua'], 'bread': ['pan'], 'milk': ['leche'], 'meat': ['carne'],
      'apple': ['manzana'], 'banana': ['pl√°tano'], 'orange': ['naranja'], 'coffee': ['caf√©'],
      'house': ['casa'], 'home': ['hogar'], 'school': ['escuela'], 'work': ['trabajo'], 
      'city': ['ciudad'], 'country': ['pa√≠s'], 'world': ['mundo'],
      'be': ['ser', 'estar'], 'have': ['tener'], 'do': ['hacer'], 'say': ['decir'], 'go': ['ir'],
      'come': ['venir'], 'see': ['ver'], 'eat': ['comer'], 'drink': ['beber'], 'sleep': ['dormir'],
      'walk': ['caminar'], 'run': ['correr'], 'play': ['jugar'], 'read': ['leer'], 'write': ['escribir'],
      'speak': ['hablar'], 'listen': ['escuchar'], 'watch': ['ver'], 'learn': ['aprender'],
      'good': ['bueno'], 'bad': ['malo'], 'big': ['grande'], 'small': ['peque√±o'], 
      'hot': ['caliente'], 'cold': ['fr√≠o'], 'new': ['nuevo'], 'old': ['viejo'], 
      'happy': ['feliz'], 'sad': ['triste'], 'beautiful': ['hermoso'], 'ugly': ['feo'],
      'how are you': ['c√≥mo est√°s'], 'what is your name': ['c√≥mo te llamas'], 
      'nice to meet you': ['mucho gusto'], 'i love you': ['te amo'], 'see you later': ['hasta luego'],
      'good morning': ['buenos d√≠as'], 'good night': ['buenas noches'], 'excuse me': ['disculpe'],
      'i am sorry': ['lo siento'], 'you are welcome': ['de nada'], 'how much': ['cu√°nto'],
      'where is': ['d√≥nde est√°'], 'i do not understand': ['no entiendo'], 'help me': ['ay√∫dame'],
      'i need': ['necesito'], 'i want': ['quiero'], 'i like': ['me gusta']
    };

    // Advanced Local AI System (Offline)
    class OfflineAI {
      constructor() {
        this.synonymDict = {
          // Spanish synonyms for better validation
          'bueno': ['bien', 'correcto', 'excelente', 'perfecto'],
          'malo': ['incorrecto', 'err√≥neo', 'equivocado'],
          'grande': ['enorme', 'gigante', 'inmenso', 'amplio'],
          'peque√±o': ['chico', 'diminuto', 'min√∫sculo', 'poco'],
          'feliz': ['alegre', 'contento', 'gozoso'],
          'triste': ['melanc√≥lico', 'deprimido', 'afligido'],
          'casa': ['hogar', 'vivienda', 'domicilio', 'residencia'],
          'trabajo': ['empleo', 'ocupaci√≥n', 'labor', 'oficio'],
          'comida': ['alimento', 'sustento', 'nutrici√≥n'],
          'agua': ['l√≠quido', 'bebida'],
          'amigo': ['compa√±ero', 'camarada', 'colega'],
          'hermoso': ['bello', 'lindo', 'precioso', 'atractivo'],
          'inteligente': ['listo', 'astuto', 'brillante', 'sabio'],
          'r√°pido': ['veloz', 'ligero', '√°gil'],
          'lento': ['pausado', 'calmado', 'tranquilo']
        };
        
        this.phoneticMap = {
          // Phonetic similarity patterns for pronunciation
          'b': ['p', 'v'], 'p': ['b'], 'v': ['b', 'f'],
          'd': ['t'], 't': ['d'], 'g': ['k'], 'k': ['g'],
          's': ['z', 'th'], 'z': ['s'], 'th': ['s', 'z'],
          'r': ['rr'], 'rr': ['r'], 'j': ['y'], 'y': ['j'],
          'c': ['k', 's'], 'qu': ['k'], 'ch': ['sh']
        };
      }

      // Advanced semantic similarity using multiple algorithms
      calculateSemanticSimilarity(word1, word2) {
        word1 = word1.toLowerCase().trim();
        word2 = word2.toLowerCase().trim();

        // Exact match
        if (word1 === word2) return 1.0;

        // Check synonyms
        if (this.synonymDict[word1]?.includes(word2) || this.synonymDict[word2]?.includes(word1)) {
          return 0.95;
        }

        // Levenshtein distance
        const levenshtein = this.levenshteinDistance(word1, word2);
        const maxLen = Math.max(word1.length, word2.length);
        const levSimilarity = 1 - (levenshtein / maxLen);

        // Jaccard similarity (character n-grams)
        const jaccardSim = this.jaccardSimilarity(word1, word2);

        // Longest Common Subsequence
        const lcsSim = this.lcsSimilarity(word1, word2);

        // Phonetic similarity
        const phoneticSim = this.phoneticSimilarity(word1, word2);

        // Weighted combination
        return (levSimilarity * 0.3) + (jaccardSim * 0.25) + (lcsSim * 0.25) + (phoneticSim * 0.2);
      }

      levenshteinDistance(str1, str2) {
        const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
        
        for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
        for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
        
        for (let j = 1; j <= str2.length; j++) {
          for (let i = 1; i <= str1.length; i++) {
            const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
            matrix[j][i] = Math.min(
              matrix[j][i - 1] + 1,     // deletion
              matrix[j - 1][i] + 1,     // insertion
              matrix[j - 1][i - 1] + cost // substitution
            );
          }
        }
        
        return matrix[str2.length][str1.length];
      }

      jaccardSimilarity(str1, str2) {
        const ngrams1 = this.getNgrams(str1, 2);
        const ngrams2 = this.getNgrams(str2, 2);
        const intersection = ngrams1.filter(x => ngrams2.includes(x));
        const union = [...new Set([...ngrams1, ...ngrams2])];
        return intersection.length / union.length;
      }

      getNgrams(str, n) {
        const ngrams = [];
        for (let i = 0; i <= str.length - n; i++) {
          ngrams.push(str.slice(i, i + n));
        }
        return ngrams;
      }

      lcsSimilarity(str1, str2) {
        const lcs = this.longestCommonSubsequence(str1, str2);
        return (2 * lcs) / (str1.length + str2.length);
      }

      longestCommonSubsequence(str1, str2) {
        const dp = Array(str1.length + 1).fill(null).map(() => Array(str2.length + 1).fill(0));
        
        for (let i = 1; i <= str1.length; i++) {
          for (let j = 1; j <= str2.length; j++) {
            if (str1[i - 1] === str2[j - 1]) {
              dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
              dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
          }
        }
        
        return dp[str1.length][str2.length];
      }

      phoneticSimilarity(word1, word2) {
        const phonetic1 = this.toPhonetic(word1);
        const phonetic2 = this.toPhonetic(word2);
        return this.calculateSemanticSimilarity(phonetic1, phonetic2);
      }

      toPhonetic(word) {
        let phonetic = word.toLowerCase();
        // Apply phonetic transformations
        Object.entries(this.phoneticMap).forEach(([key, values]) => {
          values.forEach(val => {
            phonetic = phonetic.replace(new RegExp(val, 'g'), key);
          });
        });
        return phonetic;
      }

      // Advanced translation validation
      validateTranslation(englishWord, userTranslation) {
        const correctTranslations = translationDictionary[englishWord.toLowerCase()] || [];
        
        let bestScore = 0;
        let bestMatch = '';
        let alternatives = [];

        for (const correct of correctTranslations) {
          const similarity = this.calculateSemanticSimilarity(userTranslation, correct);
          if (similarity > bestScore) {
            bestScore = similarity;
            bestMatch = correct;
          }
          if (similarity > 0.7) {
            alternatives.push(correct);
          }
        }

        // Also check for synonyms in our dictionary
        for (const [key, synonyms] of Object.entries(this.synonymDict)) {
          if (correctTranslations.includes(key)) {
            for (const synonym of synonyms) {
              const similarity = this.calculateSemanticSimilarity(userTranslation, synonym);
              if (similarity > 0.8) {
                alternatives.push(synonym);
                if (similarity > bestScore) {
                  bestScore = similarity;
                  bestMatch = synonym;
                }
              }
            }
          }
        }

        const isCorrect = bestScore >= 0.75; // 75% threshold for correctness
        
        return {
          correct: isCorrect,
          score: bestScore,
          bestMatch: bestMatch,
          explanation: isCorrect 
            ? `‚úÖ Correcto! Similitud: ${(bestScore * 100).toFixed(1)}% con "${bestMatch}"` 
            : `‚ùå Incorrecto. Mejor coincidencia: "${bestMatch}" (${(bestScore * 100).toFixed(1)}%)`,
          alternatives: [...new Set(alternatives)].slice(0, 3), // Top 3 alternatives
          method: 'An√°lisis sem√°ntico local avanzado'
        };
      }

      // Advanced pronunciation analysis
      analyzePronunciation(targetWord, spokenText, confidence) {
        const similarity = this.calculateSemanticSimilarity(targetWord.toLowerCase(), spokenText.toLowerCase());
        const phoneticMatch = this.phoneticSimilarity(targetWord, spokenText);
        
        // Calculate individual scores
        const accuracyScore = (similarity * 100);
        const clarityScore = confidence;
        const phoneticScore = (phoneticMatch * 100);
        const speedScore = 85; // Assume good speed for local analysis
        
        // Weighted overall score
        const overallScore = (accuracyScore * 0.4) + (clarityScore * 0.3) + (phoneticScore * 0.3);
        
        let feedback = '';
        let tips = '';
        
        if (overallScore >= 85) {
          feedback = '¬°Excelente pronunciaci√≥n! Muy clara y precisa.';
          tips = 'Mant√©n ese ritmo y claridad.';
        } else if (overallScore >= 70) {
          feedback = 'Buena pronunciaci√≥n, con peque√±os detalles a mejorar.';
          tips = 'Intenta pronunciar m√°s claramente las consonantes.';
        } else if (overallScore >= 50) {
          feedback = 'Pronunciaci√≥n aceptable, pero necesita pr√°ctica.';
          tips = 'Escucha el audio de ejemplo y repite lentamente.';
        } else {
          feedback = 'La pronunciaci√≥n necesita mejorar significativamente.';
          tips = 'Practica escuchando el audio varias veces antes de intentar.';
        }

        return {
          accuracy: accuracyScore,
          clarity: clarityScore,
          phoneticMatch: phoneticScore,
          overallScore: overallScore,
          feedback: feedback,
          tips: tips,
          method: 'An√°lisis fon√©tico local avanzado'
        };
      }

      // Generate smart error explanations
      generateErrorExplanation(error) {
        const { word, expected, userInput } = error;
        
        if (!userInput || userInput.trim() === '') {
          return `Para "${word}", la respuesta estaba vac√≠a. La traducci√≥n correcta es "${expected}".`;
        }

        const similarity = this.calculateSemanticSimilarity(userInput, expected);
        
        if (similarity > 0.6) {
          return `Para "${word}", tu respuesta "${userInput}" estaba muy cerca. La respuesta correcta es "${expected}". Solo necesitabas peque√±os ajustes.`;
        } else if (similarity > 0.3) {
          return `Para "${word}", tu respuesta "${userInput}" ten√≠a algunas similitudes con la correcta "${expected}", pero necesitaba m√°s precisi√≥n.`;
        } else {
          return `Para "${word}", tu respuesta "${userInput}" era muy diferente de la correcta "${expected}". Te recomiendo repasar esta palabra.`;
        }
      }
    }

    // Initialize offline AI system
    const offlineAI = new OfflineAI();

    // Particle system
    class Particle {
      constructor() {
        this.x = Math.random() * 600;
        this.y = Math.random() * 400;
        this.size = Math.random() * 4 + 2;
        this.speedX = (Math.random() - 0.5) * 2;
        this.speedY = Math.random() * 2 + 1;
        this.alpha = Math.random() * 150 + 100;
        this.color = [255, 255, 255];
        this.life = 1.0;
        this.decay = Math.random() * 0.01 + 0.005;
      }
      
      update() {
        this.x += this.speedX;
        this.y -= this.speedY;
        this.life -= this.decay;
        
        if (this.y < -this.size || this.life <= 0) {
          this.reset();
        }
        
        if (this.x < 0 || this.x > 600) {
          this.speedX *= -1;
        }
      }
      
      reset() {
        this.x = Math.random() * 600;
        this.y = 400 + this.size;
        this.life = 1.0;
      }
      
      display() {
        noStroke();
        fill(this.color[0], this.color[1], this.color[2], this.alpha * this.life);
        ellipse(this.x, this.y, this.size * this.life);
      }
    }

    // Enhanced Voice Recognition Setup with Amplification
    async function initializeEnhancedVoiceRecognition() {
      console.log('üé§ Initializing enhanced voice recognition with amplification...');
      
      try {
        // Initialize Web Audio API for amplification
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        // Request microphone access with enhanced settings
        const constraints = {
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 44100,
            channelCount: 1,
            volume: 1.0
          }
        };
        
        mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        console.log('‚úÖ Microphone access granted with enhanced settings');
        
        // Set up audio processing for amplification
        setupAudioAmplification(mediaStream);
        
        // Initialize speech recognition
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          recognition = new SpeechRecognition();
          
          // Enhanced recognition settings
          recognition.continuous = false;
          recognition.interimResults = false;
          recognition.lang = 'en-US';
          recognition.maxAlternatives = 5; // More alternatives for better matching
          
          recognition.onstart = function() {
            console.log('üé§ Enhanced voice recognition started');
            isRecording = true;
            updateMicButton();
            showVoiceWave();
            showFeedback('üé§ Listening with enhanced sensitivity... Speak clearly!', 'info');
            startVolumeMonitoring();
          };
          
          recognition.onend = function() {
            console.log('üé§ Voice recognition ended');
            isRecording = false;
            updateMicButton();
            hideVoiceWave();
            stopVolumeMonitoring();
          };
          
          recognition.onresult = function(event) {
            console.log('üó£Ô∏è Processing speech results...');
            
            // Process all alternatives for better matching
            const results = [];
            for (let i = 0; i < event.results[0].length; i++) {
              results.push({
                transcript: event.results[0][i].transcript.toLowerCase().trim(),
                confidence: event.results[0][i].confidence
              });
            }
            
            // Find best match
            const bestResult = findBestMatch(results, currentPhrase.english.toLowerCase());
            console.log(`üéØ Best match: "${bestResult.transcript}" (confidence: ${(bestResult.confidence * 100).toFixed(1)}%)`);
            
            processPronunciationResult(bestResult.transcript, bestResult.confidence);
          };
          
          recognition.onerror = function(event) {
            console.error('üö´ Speech recognition error:', event.error);
            isRecording = false;
            updateMicButton();
            hideVoiceWave();
            stopVolumeMonitoring();
            
            let errorMessage = 'Voice recognition error. ';
            switch(event.error) {
              case 'no-speech':
                errorMessage += 'No speech detected. Please speak louder and try again.';
                break;
              case 'audio-capture':
                errorMessage += 'Microphone not accessible. Check permissions.';
                break;
              case 'not-allowed':
                errorMessage += 'Microphone permission denied. Please allow access.';
                break;
              case 'network':
                errorMessage += 'Network error. Check connection and try again.';
                break;
              default:
                errorMessage += 'Please try speaking more clearly.';
            }
            
            showFeedback(errorMessage, 'error');
          };
          
          console.log('‚úÖ Enhanced voice recognition initialized successfully');
          return true;
        } else {
          throw new Error('Speech recognition not supported');
        }
        
      } catch (error) {
        console.error('‚ùå Error initializing enhanced voice recognition:', error);
        showFeedback('Enhanced voice recognition not available. Please check microphone permissions.', 'error');
        return false;
      }
    }

    function setupAudioAmplification(stream) {
      try {
        // Create audio nodes for amplification
        microphone = audioContext.createMediaStreamSource(stream);
        gainNode = audioContext.createGain();
        analyser = audioContext.createAnalyser();
        
        // Set up amplification (increase gain for better detection)
        gainNode.gain.value = 2.5; // Amplify input by 2.5x
        
        // Configure analyser for volume monitoring
        analyser.fftSize = 256;
        analyser.smoothingTimeConstant = 0.8;
        
        // Connect audio nodes
        microphone.connect(gainNode);
        gainNode.connect(analyser);
        
        console.log('üîä Audio amplification setup complete (2.5x gain)');
      } catch (error) {
        console.error('‚ùå Error setting up audio amplification:', error);
      }
    }

    function findBestMatch(results, targetWord) {
      let bestMatch = results[0];
      let bestSimilarity = 0;
      
      for (let result of results) {
        const similarity = calculateEnhancedSimilarity(result.transcript, targetWord);
        const weightedScore = (similarity * 0.7) + (result.confidence * 100 * 0.3);
        
        if (weightedScore > bestSimilarity) {
          bestSimilarity = weightedScore;
          bestMatch = result;
        }
      }
      
      return bestMatch;
    }

    function calculateEnhancedSimilarity(spoken, target) {
      // Enhanced similarity calculation with relaxed matching
      const spokenNorm = normalizeForComparison(spoken);
      const targetNorm = normalizeForComparison(target);
      
      console.log(`üîç Comparing: "${spokenNorm}" vs "${targetNorm}"`);
      
      // Exact match - highest score
      if (spokenNorm === targetNorm) {
        console.log('‚úÖ Exact match found!');
        return 100;
      }
      
      // Check if spoken contains target or vice versa
      if (spokenNorm.includes(targetNorm) || targetNorm.includes(spokenNorm)) {
        console.log('‚úÖ Partial match found!');
        return 85;
      }
      
      // Levenshtein distance with relaxed threshold
      const distance = levenshteinDistance(spokenNorm, targetNorm);
      const maxLength = Math.max(spokenNorm.length, targetNorm.length);
      const similarity = Math.max(0, (maxLength - distance) / maxLength * 100);
      
      // Check for phonetic similarity (common mispronunciations)
      const phoneticSimilarity = checkPhoneticSimilarity(spokenNorm, targetNorm);
      
      // Use the higher score
      const finalSimilarity = Math.max(similarity, phoneticSimilarity);
      
      console.log(`üìä Similarity scores: Levenshtein=${similarity.toFixed(1)}%, Phonetic=${phoneticSimilarity.toFixed(1)}%, Final=${finalSimilarity.toFixed(1)}%`);
      
      return finalSimilarity;
    }

    function normalizeForComparison(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z\s]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function checkPhoneticSimilarity(spoken, target) {
      // Common phonetic replacements for better matching
      const phoneticMap = {
        'ph': 'f', 'th': 't', 'ck': 'k', 'ch': 'sh',
        'c': 'k', 'z': 's', 'x': 'ks', 'qu': 'kw'
      };
      
      let spokenPhonetic = spoken;
      let targetPhonetic = target;
      
      // Apply phonetic transformations
      for (let [pattern, replacement] of Object.entries(phoneticMap)) {
        spokenPhonetic = spokenPhonetic.replace(new RegExp(pattern, 'g'), replacement);
        targetPhonetic = targetPhonetic.replace(new RegExp(pattern, 'g'), replacement);
      }
      
      // Calculate similarity on phonetic versions
      const distance = levenshteinDistance(spokenPhonetic, targetPhonetic);
      const maxLength = Math.max(spokenPhonetic.length, targetPhonetic.length);
      return Math.max(0, (maxLength - distance) / maxLength * 100);
    }

    function startVolumeMonitoring() {
      if (!analyser) return;
      
      const volumeIndicator = document.getElementById('volumeIndicator');
      volumeIndicator.style.display = 'flex';
      
      function updateVolume() {
        if (!isRecording || !analyser) return;
        
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(dataArray);
        
        // Calculate average volume
        const average = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;
        const volumePercent = (average / 255) * 100;
        
        // Update volume indicator
        if (volumePercent > 20) {
          volumeIndicator.textContent = 'üîä';
          volumeIndicator.style.background = '#4ecdc4';
        } else if (volumePercent > 10) {
          volumeIndicator.textContent = 'üîâ';
          volumeIndicator.style.background = '#ffa726';
        } else {
          volumeIndicator.textContent = 'üîà';
          volumeIndicator.style.background = '#ff6b6b';
        }
        
        if (isRecording) {
          requestAnimationFrame(updateVolume);
        }
      }
      
      updateVolume();
    }

    function stopVolumeMonitoring() {
      const volumeIndicator = document.getElementById('volumeIndicator');
      volumeIndicator.style.display = 'none';
    }

    function normalizeText(text) {
      return text
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-zA-Z\s]/g, '')
        .trim();
    }

    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    function generatePhonetic(word) {
      const phoneticMap = {
        'a': 'AH', 'e': 'EH', 'i': 'EE', 'o': 'OH', 'u': 'OO',
        'y': 'EE', 'ch': 'CH', 'sh': 'SH', 'th': 'TH'
      };
      
      let phonetic = word.toUpperCase();
      for (let [pattern, replacement] of Object.entries(phoneticMap)) {
        phonetic = phonetic.replace(new RegExp(pattern.toUpperCase(), 'g'), replacement);
      }
      
      return phonetic;
    }

    function setup() {
      createCanvas(600, 400);
      document.getElementById('fileInput').addEventListener('change', handleFile);
      color1 = color(102, 126, 234);
      color2 = color(118, 75, 162);
      
      // Initialize particles
      for (let i = 0; i < 40; i++) {
        particles.push(new Particle());
      }
      
      // Initialize enhanced voice recognition
      initializeEnhancedVoiceRecognition();
      
      // Load default words immediately
      loadDefaultWords();
      
      console.log('üéÆ Enhanced game initialized successfully!');
      console.log(`üìÖ Session Date: ${getCurrentDateTime()}`);
      console.log(`üë§ User: ${getCurrentUser()}`);
    }

    function loadDefaultWords() {
      phrases = [];
      const words = Object.keys(translationDictionary);
      
      console.log(`üìö Loading ${words.length} default words...`);
      
      for (let word of words) {
        const translations = translationDictionary[word];
        phrases.push({
          english: word,
          spanish: translations.map(normalizeText),
          pronunciation: `/Generated/`,
          phonetic: generatePhonetic(word)
        });
      }
      
      fileLoaded = true;
      updateUI();
      console.log('‚úÖ Default vocabulary loaded:', phrases.length, 'words');
    }

    function drawAnimatedBackground() {
      for (let y = 0; y < height; y++) {
        let inter = map(y, 0, height, 0, 1);
        let wave = sin(frameCount * 0.02 + y * 0.01) * 0.1;
        let c = lerpColor(color1, color2, inter + wave);
        stroke(c);
        line(0, y, width, y);
      }
      
      for (let p of particles) {
        p.update();
        p.display();
      }
    }

    function draw() {
      drawAnimatedBackground();
      
      textAlign(CENTER, CENTER);
      fill(255);
      textSize(24);
      
      switch(gameState) {
        case 'countdown':
          drawCountdown();
          break;
        case 'waiting':
          drawWaitingScreen();
          break;
        case 'playing':
          drawGameplay();
          break;
        case 'voiceRecognition':
          drawVoiceRecognition();
          break;
        case 'finalResults':
          drawFinalResults();
          break;
      }
    }

    function drawCountdown() {
      let elapsed = millis() - countdownTimer;
      let currentNumber = Math.floor(3 - elapsed / 1000);
      
      if (currentNumber < 1) {
        startMainGame();
        return;
      }
      
      textSize(100);
      fill(255, 215, 0);
      text(currentNumber, width/2, height/2);
    }

    function drawWaitingScreen() {
      if (!fileLoaded && phrases.length === 0) {
        text('üöÄ Loading Game...', width/2, height/2 - 40);
        textSize(18);
        text('Preparing enhanced voice recognition', width/2, height/2 + 20);
      } else {
        text('üéØ Ready to Begin!', width/2, height/2 - 40);
        textSize(20);
        text(`${phrases.length} words loaded with enhanced voice`, width/2, height/2 + 20);
      }
    }

    function drawGameplay() {
      if (!currentPhrase) return;
      
      // Solo reduce el tiempo si no est√° pausado
      if (!timerPaused) {
        timeLeft -= 1 / frameRate();
        if (timeLeft <= 0) {
          handleTimeout();
          return;
        }
      }
      
      updateGameUI();
    }

    function drawVoiceRecognition() {
      fill(255, 165, 0);
      textSize(28);
      text('üé§ Enhanced Voice Recognition', width/2, height/2 - 80);
      
      fill(255);
      textSize(24);
      text(`Practice: "${currentPhrase.english}"`, width/2, height/2 - 40);
      
      fill(255, 165, 0);
      textSize(18);
      text(`Round ${currentPronunciationRound} of 3 (Relaxed Matching)`, width/2, height/2);
      
      // Show recording status
      if (isRecording) {
        fill(255, 107, 107);
        textSize(16);
        text('üî¥ Recording with amplification...', width/2, height/2 + 40);
      }
    }

    function drawFinalResults() {
      fill(255, 215, 0);
      textSize(40);
      text('üéâ Game Complete!', width/2, height/2 - 100);
      
      fill(255);
      textSize(24);
      text('Check your comprehensive results below', width/2, height/2 - 50);
      
      let accuracy = correctAnswers / (correctAnswers + incorrectTranslations) * 100;
      let avgTime = totalGameTime / (correctAnswers + incorrectTranslations);
      
      updateFinalStats(accuracy, avgTime);
    }

    function updateGameUI() {
      if (!currentPhrase) return;
      
      document.getElementById('currentWordDisplay').textContent = `"${currentPhrase.english}"`;
      document.getElementById('scoreDisplay').textContent = score;
      document.getElementById('correctDisplay').textContent = correctAnswers;
      document.getElementById('incorrectDisplay').textContent = incorrectTranslations;
      document.getElementById('roundDisplay').textContent = `${round + 1}/${roundSize}`;
      
      const timerEl = document.getElementById('timerDisplay');
      const timeDisplay = Math.ceil(timeLeft);
      timerEl.textContent = `‚è∞ ${timeDisplay}s`;
      
      if (timeLeft <= 3) {
        timerEl.style.color = '#ff6b6b';
        timerEl.style.borderColor = '#ff6b6b';
        timerEl.style.animation = 'pulse 0.3s ease-in-out infinite';
      } else if (timeLeft <= 5) {
        timerEl.style.color = '#ffa726';
        timerEl.style.borderColor = '#ffa726';
        timerEl.style.animation = 'pulse 0.5s ease-in-out infinite';
      } else {
        timerEl.style.color = '#4ecdc4';
        timerEl.style.borderColor = '#4ecdc4';
        timerEl.style.animation = 'none';
      }
    }

    function updateFinalStats(accuracy, avgTime) {
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalAccuracy').textContent = `${accuracy.toFixed(1)}%`;
      document.getElementById('finalTime').textContent = `${avgTime.toFixed(1)}s`;
      document.getElementById('pronunciationAccuracy').textContent = `${(totalPronunciationScore / round).toFixed(1)}%`;
      document.getElementById('finalStats').style.display = 'grid';
    }

    function updateUI() {
      if (fileLoaded && phrases.length > 0) {
        document.getElementById('startButton').style.display = 'block';
        document.getElementById('loadingContainer').style.display = 'none';
        console.log('‚úÖ UI updated - Start button now visible');
      }
    }

    function updateProgressBar(progress) {
      const progressPercent = Math.floor(progress * 100);
      document.getElementById('progressFill').style.width = progressPercent + '%';
      document.getElementById('progressPercent').textContent = progressPercent + '%';
      
      document.getElementById('processedCount').textContent = processedCount;
      document.getElementById('translatedCount').textContent = translatedCount;
      document.getElementById('failedCount').textContent = failedCount;
      document.getElementById('cacheHits').textContent = cacheHits;
    }

    // Enhanced Voice Recognition Functions
    function startVoiceRecognitionPhase() {
      console.log('üé§ Starting enhanced voice recognition phase');
      gameState = 'voiceRecognition';
      
      // Reset pronunciation state
      currentPronunciationRound = 1;
      pronunciationResults = [];
      pronunciationStartTime = millis();
      
      // Hide translation input and show voice recognition
      document.getElementById('translationInput').style.display = 'none';
      document.getElementById('voiceRecognition').style.display = 'block';
      
      // Set up the word to practice
      document.getElementById('pronunciationWord').textContent = currentPhrase.english;
      document.getElementById('phoneticDisplay').textContent = currentPhrase.phonetic;
      
      // Reset all rounds to pending
      resetPronunciationRounds();
      
      // Start first round automatically after showing example
      setTimeout(() => {
        playPronunciationExample();
      }, 1000);
    }

    function resetPronunciationRounds() {
      for (let i = 1; i <= 3; i++) {
        const roundEl = document.getElementById(`round${i}`);
        roundEl.className = 'round-card round-pending';
        document.getElementById(`round${i}Status`).textContent = 'Pending';
      }
      updatePronunciationScores(0, 0, 0, 0);
    }

    function playPronunciationExample() {
      showFeedback('üîä Listen to the correct pronunciation first...', 'info');
      playPronunciation(1.0, () => {
        setTimeout(() => {
          showFeedback('üé§ Now it\'s your turn! Click the microphone to start (relaxed matching enabled).', 'info');
          setActiveRound(1);
        }, 1000);
      });
    }

    function playPronunciation(rate = 1.0, callback = null) {
      if (speechSynthesis) {
        // Stop any ongoing speech
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(currentPhrase.english);
        utterance.lang = 'en-US';
        utterance.rate = rate;
        utterance.pitch = 1;
        utterance.volume = 1;
        
        if (callback) {
          utterance.onend = callback;
        }
         speechSynthesis.speak(utterance);
        console.log(`üîä Playing pronunciation at rate ${rate}`);
      } else {
        console.warn('‚ö†Ô∏è Speech synthesis not available');
        if (callback) callback();
      }
    }

    function playSlowPronunciation() {
      playPronunciation(0.6);
    }

    function playRepeatPronunciation() {
      let count = 0;
      function playNext() {
        if (count < 3) {
          count++;
          playPronunciation(1.0, () => {
            setTimeout(playNext, 800);
          });
        }
      }
      playNext();
    }

    function setActiveRound(roundNumber) {
      // Reset all rounds
      for (let i = 1; i <= 3; i++) {
        const roundEl = document.getElementById(`round${i}`);
        if (i < roundNumber) {
          // Already completed rounds
          continue;
        } else if (i === roundNumber) {
          roundEl.className = 'round-card round-active';
          document.getElementById(`round${i}Status`).textContent = 'Active';
        } else {
          roundEl.className = 'round-card round-pending';
          document.getElementById(`round${i}Status`).textContent = 'Pending';
        }
      }
      currentPronunciationRound = roundNumber;
    }

    function startRecording() {
      if (!recognition) {
        showFeedback('Enhanced voice recognition not available. Please check microphone permissions.', 'error');
        return;
      }
      
      if (isRecording) {
        recognition.stop();
        return;
      }
      
      try {
        // Resume audio context if suspended
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }
        
        recognition.start();
      } catch (error) {
        console.error('Error starting enhanced recognition:', error);
        showFeedback('Error starting voice recognition. Please try again.', 'error');
      }
    }

    async function processPronunciationResult(spokenText, confidence) {
      const targetWord = currentPhrase.english.toLowerCase();
      
      console.log(`üéØ Target: "${targetWord}", Spoken: "${spokenText}"`);
      console.log(`üìä Confidence: ${(confidence * 100).toFixed(1)}%`);
      
      // Show processing message
      showFeedback(`ü§ñ Analizando pronunciaci√≥n con IA...`, 'info');
      
      try {
        // Use AI for detailed pronunciation analysis
        const aiAnalysis = await analyzePronunciationWithAI(targetWord, spokenText, confidence * 100);
        
        let accuracyScore, clarityScore, phoneticScore, overallScore, detailedFeedback;
        
        if (aiAnalysis) {
          // Use AI analysis
          accuracyScore = aiAnalysis.accuracy;
          clarityScore = aiAnalysis.clarity;
          phoneticScore = aiAnalysis.phoneticMatch;
          overallScore = aiAnalysis.overallScore;
          detailedFeedback = aiAnalysis.feedback;
        } else {
          // Fallback to original method
          const similarity = calculateEnhancedSimilarity(spokenText, targetWord);
          accuracyScore = similarity;
          clarityScore = confidence * 100;
          phoneticScore = similarity;
          overallScore = (accuracyScore * 0.4) + (clarityScore * 0.3) + (phoneticScore * 0.3);
          detailedFeedback = `An√°lisis b√°sico: similitud ${similarity.toFixed(1)}%`;
        }
        
        const speedScore = calculateSpeedScore();
        
        // Store result with AI analysis
        pronunciationResults.push({
          round: currentPronunciationRound,
          spoken: spokenText,
          accuracy: accuracyScore,
          clarity: clarityScore,
          phonetic: phoneticScore,
          speed: speedScore,
          overall: overallScore,
          aiAnalysis: aiAnalysis,
          detailedFeedback: detailedFeedback
        });
        
        // Update round status
        const roundEl = document.getElementById(`round${currentPronunciationRound}`);
        const statusEl = document.getElementById(`round${currentPronunciationRound}Status`);
        
        let feedbackMessage = '';
        let feedbackType = '';
        
        if (overallScore >= 80) {
          roundEl.className = 'round-card round-success';
          statusEl.textContent = `${overallScore.toFixed(0)}% üåü`;
          feedbackMessage = `üåü ¬°Excelente pronunciaci√≥n! Puntuaci√≥n: ${overallScore.toFixed(1)}%`;
          feedbackType = 'success';
        } else if (overallScore >= 65) {
          roundEl.className = 'round-card round-success';
          statusEl.textContent = `${overallScore.toFixed(0)}% ‚úÖ`;
          feedbackMessage = `‚úÖ ¬°Muy buena pronunciaci√≥n! Puntuaci√≥n: ${overallScore.toFixed(1)}%`;
          feedbackType = 'success';
        } else if (overallScore >= 50) {
          roundEl.className = 'round-card round-success';
          statusEl.textContent = `${overallScore.toFixed(0)}% ‚ö†Ô∏è`;
          feedbackMessage = `‚ö†Ô∏è Buena pronunciaci√≥n. Puntuaci√≥n: ${overallScore.toFixed(1)}%`;
          feedbackType = 'info';
        } else if (overallScore >= 30) {
          roundEl.className = 'round-card round-failed';
          statusEl.textContent = `${overallScore.toFixed(0)}% üîÑ`;
          feedbackMessage = `üîÑ Necesita mejorar. Puntuaci√≥n: ${overallScore.toFixed(1)}%`;
          feedbackType = 'error';
        } else {
          roundEl.className = 'round-card round-failed';
          statusEl.textContent = `${overallScore.toFixed(0)}% ‚ùå`;
          feedbackMessage = `‚ùå Pronunciaci√≥n muy diferente. Puntuaci√≥n: ${overallScore.toFixed(1)}%`;
          feedbackType = 'error';
        }
        
        // Show detailed feedback
        if (aiAnalysis && aiAnalysis.feedback) {
          feedbackMessage += `<br><br><strong>An√°lisis detallado:</strong> ${aiAnalysis.feedback}`;
          if (aiAnalysis.tips) {
            feedbackMessage += `<br><br><strong>üí° Consejo:</strong> ${aiAnalysis.tips}`;
          }
        }
        
        showFeedback(feedbackMessage, feedbackType);
        
        // Update scores display with more detail
        updateDetailedPronunciationScores(accuracyScore, clarityScore, phoneticScore, speedScore, overallScore);
        
        // Move to next round or finish
        if (currentPronunciationRound < 3) {
          setTimeout(() => {
            currentPronunciationRound++;
            setActiveRound(currentPronunciationRound);
            showFeedback(`üé§ Ronda ${currentPronunciationRound} de 3: Haz clic en el micr√≥fono para continuar`, 'info');
          }, 4000); // M√°s tiempo para leer el feedback
        } else {
          // All 3 rounds completed - call finish directly
          console.log('üéä All 3 rounds completed, calling finishPronunciationPhase');
          setTimeout(() => {
            finishPronunciationPhase();
          }, 3000);
        }
        
      } catch (error) {
        console.error('Error in pronunciation analysis:', error);
        // Fallback to basic analysis
        const similarity = calculateEnhancedSimilarity(spokenText, targetWord);
        const basicScore = (similarity + confidence * 100) / 2;
        
        pronunciationResults.push({
          round: currentPronunciationRound,
          spoken: spokenText,
          accuracy: similarity,
          clarity: confidence * 100,
          phonetic: similarity,
          speed: calculateSpeedScore(),
          overall: basicScore
        });
        
        showFeedback(`üîç Puntuaci√≥n b√°sica: ${basicScore.toFixed(1)}%`, 'info');
        
        if (currentPronunciationRound < 3) {
          currentPronunciationRound++;
          setActiveRound(currentPronunciationRound);
        } else {
          finishPronunciationPhase();
        }
      }
    }

    function levenshteinDistance(str1, str2) {
      const matrix = [];
      
      for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
          if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1,
              matrix[i][j - 1] + 1,
              matrix[i - 1][j] + 1
            );
          }
        }
      }
      
      return matrix[str2.length][str1.length];
    }

    function calculateSpeedScore() {
      const elapsedTime = (millis() - pronunciationStartTime) / 1000;
      const targetTime = 3; // 3 seconds is optimal
      
      if (elapsedTime <= targetTime) {
        return 100;
      } else if (elapsedTime <= targetTime * 2) {
        return Math.max(60, 100 - (elapsedTime - targetTime) * 20);
      } else {
        return 40;
      }
    }

    function updateDetailedPronunciationScores(accuracy, clarity, phonetic, speed, overall) {
      document.getElementById('accuracyScore').textContent = `${accuracy.toFixed(1)}%`;
      document.getElementById('clarityScore').textContent = `${clarity.toFixed(1)}%`;
      document.getElementById('speedScore').textContent = `${speed.toFixed(1)}%`;
      document.getElementById('overallScore').textContent = `${overall.toFixed(1)}%`;
      
      // Add phonetic score if element exists
      const phoneticEl = document.getElementById('phoneticScore');
      if (phoneticEl) {
        phoneticEl.textContent = `${phonetic.toFixed(1)}%`;
      }
    }

    function updatePronunciationScores(accuracy, clarity, speed, overall) {
      document.getElementById('accuracyScore').textContent = `${accuracy.toFixed(0)}%`;
      document.getElementById('clarityScore').textContent = `${clarity.toFixed(0)}%`;
      document.getElementById('speedScore').textContent = `${speed.toFixed(0)}%`;
      document.getElementById('overallScore').textContent = `${overall.toFixed(0)}%`;
    }

    function finishPronunciationPhase() {
      console.log('üèÅ Finishing enhanced pronunciation phase');
      
      // Calculate average pronunciation score for this word
      const avgScore = pronunciationResults.reduce((sum, result) => sum + result.overall, 0) / pronunciationResults.length;
      totalPronunciationScore += avgScore;
      
    function finishPronunciationPhase() {
      console.log('üèÅ Finishing enhanced pronunciation phase');
      
      // Calculate average pronunciation score for this word
      const avgScore = pronunciationResults.reduce((sum, result) => sum + result.overall, 0) / pronunciationResults.length;
      totalPronunciationScore += avgScore;
      
      // Determine if pronunciation passed (60% threshold)
      const pronunciationPassed = avgScore >= 60;
      const translationPassed = window.currentWordTranslationCorrect;
      
      // EVALUACI√ìN FINAL: Ambos deben estar correctos para contar como respuesta correcta
      const bothCorrect = translationPassed && pronunciationPassed;
      
      if (bothCorrect) {
        // Solo ahora incrementar score y correctAnswers
        score += Math.max(10, Math.floor(timeLeft * 2));
        correctAnswers++;
        console.log('‚úÖ Both translation and pronunciation correct - counted as success');
      } else {
        // Cualquier fallo cuenta como incorrecto
        incorrectTranslations++;
        console.log('‚ùå Either translation or pronunciation failed - counted as error');
        
        // Determine error type and create comprehensive error entry
        let errorEntry;
        
        if (window.currentTranslationError) {
          // Translation was wrong, update with pronunciation results
          errorEntry = { ...window.currentTranslationError };
          errorEntry.pronunciationError = !pronunciationPassed;
          errorEntry.pronunciationScore = Math.round(avgScore);
        } else {
          // Translation was correct but pronunciation failed
          errorEntry = {
            word: currentPhrase.english,
            expected: currentPhrase.spanish.join(' / '),
            userInput: '(traducci√≥n correcta)',
            pronunciation: currentPhrase.pronunciation,
            phonetic: currentPhrase.phonetic,
            translationError: false,
            pronunciationError: true,
            pronunciationScore: Math.round(avgScore)
          };
        }
        
        // Add detailed pronunciation data
        errorEntry.pronunciationData = {
          averageScore: Math.round(avgScore),
          detailedResults: pronunciationResults,
          aiAnalysis: pronunciationResults.filter(r => r.aiAnalysis).map(r => r.aiAnalysis),
          rounds: pronunciationResults.length
        };
        
        errors.push(errorEntry);
      }
      
      // Clean up temporary data
      window.currentTranslationError = null;
      
      // Hide voice recognition interface
      document.getElementById('voiceRecognition').style.display = 'none';
      
      // Show comprehensive results summary
      const bestRound = Math.max(...pronunciationResults.map(r => r.overall));
      const worstRound = Math.min(...pronunciationResults.map(r => r.overall));
      
      let resultMessage = `üéØ Evaluaci√≥n completa:<br>`;
      resultMessage += `üìù Traducci√≥n: ${translationPassed ? '‚úÖ Correcta' : '‚ùå Incorrecta'}<br>`;
      resultMessage += `üîä Pronunciaci√≥n: ${pronunciationPassed ? '‚úÖ Correcta' : '‚ùå Incorrecta'} (${avgScore.toFixed(1)}%)<br>`;
      resultMessage += `üèÜ Resultado final: ${bothCorrect ? '‚úÖ CORRECTO' : '‚ùå INCORRECTO'}<br><br>`;
      resultMessage += `üìä Detalle pronunciaci√≥n:<br>`;
      resultMessage += `‚Ä¢ Promedio: ${avgScore.toFixed(1)}%<br>`;
      resultMessage += `‚Ä¢ Mejor ronda: ${bestRound.toFixed(1)}%<br>`;
      resultMessage += `‚Ä¢ Rango: ${worstRound.toFixed(1)}% - ${bestRound.toFixed(1)}%`;
      
      const feedbackType = bothCorrect ? 'success' : 'error';
      showFeedback(resultMessage, feedbackType);
      
      // Continue to next round
      setTimeout(() => {
        nextRound();
      }, 4000); // M√°s tiempo para leer el resultado completo
    }
    }

    function updateMicButton() {
      const micButton = document.getElementById('micButton');
      if (isRecording) {
        micButton.className = 'mic-button recording';
        micButton.innerHTML = 'üî¥<div class="mic-volume-indicator" id="volumeIndicator" style="display: flex;">üìä</div>';
        micButton.title = 'Recording with amplification... Click to stop';
      } else {
        micButton.className = 'mic-button';
        micButton.innerHTML = 'üé§<div class="mic-volume-indicator" id="volumeIndicator">üìä</div>';
        micButton.title = 'Click to start enhanced recording';
      }
    }

    function showVoiceWave() {
      document.getElementById('voiceWave').style.display = 'flex';
    }

    function hideVoiceWave() {
      document.getElementById('voiceWave').style.display = 'none';
    }

    function showFeedback(message, type) {
      const feedbackEl = document.getElementById('voiceFeedback');
      feedbackEl.innerHTML = `<div class="voice-feedback feedback-${type}">${message}</div>`;
      
      // Auto-clear success and info messages after 5 seconds
      if (type === 'success' || type === 'info') {
        setTimeout(() => {
          if (feedbackEl.innerHTML.includes(message)) {
            feedbackEl.innerHTML = '';
          }
        }, 5000);
      }
    }

    function showTranslationFeedback(message, type) {
      // Use the existing feedback element
      const feedbackEl = document.getElementById('translationFeedback');
      feedbackEl.innerHTML = `<div class="voice-feedback feedback-${type}" style="margin: 10px 0;">${message}</div>`;
      
      // Don't auto-clear error messages to allow reading
      if (type === 'success' || type === 'info') {
        setTimeout(() => {
          if (feedbackEl.innerHTML.includes(message)) {
            feedbackEl.innerHTML = '';
          }
        }, 4000);
      }
    }

    // AI Translation Validation Functions
    async function validateTranslationWithAI(englishWord, userTranslation) {
      const cacheKey = `${englishWord}_${userTranslation}`;
      
      if (aiCache.has(cacheKey)) {
        console.log('üß† Using cached validation result');
        return aiCache.get(cacheKey);
      }

      console.log(`ü§ñ Validating offline: "${englishWord}" -> "${userTranslation}"`);
      
      // Use offline AI system instead of external API
      const result = offlineAI.validateTranslation(englishWord, userTranslation);
      
      // Cache the result
      aiCache.set(cacheKey, result);
      
      console.log('üß† Offline validation result:', result);
      return result;
    }

    async function analyzePronunciationWithAI(targetWord, spokenText, confidence) {
      console.log(`ü§ñ Analyzing pronunciation offline: "${targetWord}" vs "${spokenText}"`);
      
      // Use offline AI system instead of external API
      const result = offlineAI.analyzePronunciation(targetWord, spokenText, confidence);
      
      console.log('üß† Offline pronunciation analysis:', result);
      return result;
    }

    async function generateErrorExplanations(errors) {
      if (errors.length === 0) return [];

      console.log('ü§ñ Generating error explanations offline...');
      
      // Use offline AI system to generate explanations
      const explanations = errors.map(error => ({
        word: error.word,
        explanation: offlineAI.generateErrorExplanation(error),
        tips: error.pronunciationError 
          ? 'Practica la pronunciaci√≥n escuchando el audio varias veces.'
          : 'Repasa esta traducci√≥n y sus sin√≥nimos.'
      }));
      
      console.log('üß† Offline explanations generated:', explanations.length);
      return explanations;
    }
    async function handleFile(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      if (!file.name.endsWith('.txt')) {
        alert('üìÑ Please upload a .txt file.');
        return;
      }
      
      console.log(`üìÅ Processing file: ${file.name} (${file.size} bytes)`);
      
      processingWords = true;
      processedCount = 0;
      translatedCount = 0;
      failedCount = 0;
      cacheHits = 0;
      phrases = [];
      
      document.getElementById('loadingContainer').style.display = 'block';
      document.getElementById('wordStats').style.display = 'block';
      document.getElementById('loadingText').innerHTML = '<span class="processing-indicator"></span>Reading and analyzing file...';
      
      const reader = new FileReader();
      reader.onload = async (e) => {
        const content = e.target.result;
        console.log(`üìñ File content length: ${content.length} characters`);
        
        const analysis = analyzeText(content);
        displayFileAnalysis(analysis);
        
        const items = extractWordsAndSentences(content);
        totalWords = items.length;
        
        console.log(`üîç Extracted ${totalWords} items for processing`);
        
        if (totalWords === 0) {
          alert('‚ùå No valid words or sentences found in the file.');
          processingWords = false;
          return;
        }
        
        document.getElementById('progressText').textContent = `Processing ${totalWords} items...`;
        
        await processAllItems(items);
      };
      
      reader.onerror = () => {
        alert('‚ùå Error reading file. Please try again.');
        processingWords = false;
      };
      
      reader.readAsText(file);
    }

    function analyzeText(content) {
      const words = content.toLowerCase().match(/\b[a-z]+\b/g) || [];
      const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
      const characters = content.length;
      const uniqueWords = [...new Set(words)];
      
      return {
        totalWords: words.length,
        uniqueWords: uniqueWords.length,
        sentences: sentences.length,
        characters: characters
      };
    }

    function displayFileAnalysis(analysis) {
      document.getElementById('fileInfo').style.display = 'block';
      document.getElementById('totalWordsCount').textContent = analysis.totalWords;
      document.getElementById('uniqueWordsCount').textContent = analysis.uniqueWords;
      document.getElementById('sentencesCount').textContent = analysis.sentences;
      document.getElementById('charactersCount').textContent = analysis.characters;
      
      console.log('üìä File Analysis:', analysis);
    }

    function extractWordsAndSentences(content) {
      const items = [];
      
      const words = content.toLowerCase().match(/\b[a-z]+\b/g) || [];
      const uniqueWords = [...new Set(words)];
      
      const sentences = content.split(/[.!?]+/)
        .map(s => s.trim().toLowerCase())
        .filter(s => s.length > 0 && s.length < 100)
        .filter(s => s.split(' ').length >= 2);
      
      uniqueWords.forEach(word => {
        if (word.length > 1) {
          items.push({
            type: 'word',
            text: word,
            original: word
          });
        }
      });
      
      sentences.forEach(sentence => {
        items.push({
          type: 'sentence',
          text: sentence,
          original: sentence
        });
      });
      
      console.log(`üìù Extracted: ${uniqueWords.length} words + ${sentences.length} sentences = ${items.length} total items`);
      return items;
    }

    async function processAllItems(items) {
      phrases = [];
      
      document.getElementById('progressText').textContent = 'Processing with comprehensive dictionary...';
      
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        let translations = null;
        
        try {
          if (translationDictionary[item.text]) {
            translations = translationDictionary[item.text];
            cacheHits++;
          } else if (translationCache[item.text]) {
            translations = translationCache[item.text];
            cacheHits++;
          } else if (item.type === 'sentence') {
            translations = translateSentence(item.text);
          } else {
            translations = findSimilarTranslation(item.text);
          }
          
          if (translations && translations.length > 0) {
            phrases.push({
              english: item.text,
              spanish: translations.map(normalizeText),
              pronunciation: `/Generated/`,
              phonetic: generatePhonetic(item.text),
              type: item.type
            });
            
            translationCache[item.text] = translations;
            translatedCount++;
          } else {
            phrases.push({
              english: item.text,
              spanish: [item.text],
              pronunciation: `/Unknown/`,
              phonetic: generatePhonetic(item.text),
              type: item.type
            });
            failedCount++;
          }
        } catch (error) {
          console.warn(`Error processing "${item.text}":`, error);
          failedCount++;
        }
        
        processedCount++;
        updateProgressBar(processedCount / totalWords);
        
        if (processedCount % 50 === 0) {
          document.getElementById('progressText').textContent = 
            `Processed ${processedCount}/${totalWords} items...`;
        }
        
        if (i % 100 === 0) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      
      processingWords = false;
      fileLoaded = true;
      
      document.getElementById('loadingText').innerHTML = 
        `<span style="color: #4ecdc4;">‚úÖ Processing Complete!</span>`;
      document.getElementById('progressText').textContent = 
        `Successfully processed ${phrases.length} items`;
      
      setTimeout(() => {
        document.getElementById('loadingContainer').style.display = 'none';
        updateUI();
      }, 2000);
      
      console.log(`‚úÖ Processing complete: ${phrases.length}/${totalWords} items processed successfully`);
    }

    function translateSentence(sentence) {
      const words = sentence.split(' ');
      const translatedWords = [];
      
      for (let word of words) {
        if (translationDictionary[word]) {
          translatedWords.push(translationDictionary[word][0]);
        } else {
          translatedWords.push(word);
        }
      }
      
      return [translatedWords.join(' ')];
    }

    function findSimilarTranslation(word) {
      const keys = Object.keys(translationDictionary);
      
      for (let key of keys) {
        if (key.includes(word) || word.includes(key)) {
          return translationDictionary[key];
        }
      }
      
      if (word.length > 3) {
        const ending = word.slice(-3);
        for (let key of keys) {
          if (key.endsWith(ending) && key.length > 3) {
            return translationDictionary[key];
          }
        }
      }
      
      return null;
    }

    function startPlaying() {
      console.log('üéÆ Starting enhanced game...');
      
      if (phrases.length === 0) {
        alert('‚ùå No words available. Please wait for words to load or upload a file.');
        return;
      }
      
      const roundSizeSelection = document.getElementById('roundSizeSelect').value;
      console.log(`üìä Round size selection: ${roundSizeSelection}`);
      
      if (roundSizeSelection === '25') {
        roundSize = Math.min(25, phrases.length);
      } else if (roundSizeSelection === '50') {
        roundSize = Math.min(50, phrases.length);
      } else if (roundSizeSelection === '100') {
        roundSize = Math.min(100, phrases.length);
      } else if (roundSizeSelection === 'half') {
        roundSize = Math.floor(phrases.length / 2);
      } else {
        roundSize = phrases.length;
      }
      
      console.log(`üéØ Starting game with ${roundSize} words out of ${phrases.length} available`);
      
      resetGameState();
      currentRoundWords = shuffleArray(phrases).slice(0, roundSize);
      
      gameState = 'countdown';
      countdownTimer = millis();
      startTime = millis();
      
      hideControls();
      showGameElements();
    }

    function resetGameState() {
      score = 0;
      correctAnswers = 0;
      incorrectTranslations = 0;
      round = 0;
      errors = [];
      currentPhraseIndex = 0;
      waitingForPronunciation = false;
      pronunciationAttempts = 0;
      totalPronunciationScore = 0;
    }

    function hideControls() {
      document.getElementById('controlsPanel').style.display = 'none';
      document.getElementById('startButton').style.display = 'none';
      document.getElementById('finalStats').style.display = 'none';
      document.getElementById('errorsReview').style.display = 'none';
      document.getElementById('fileInfo').style.display = 'none';
    }

    function showGameElements() {
      document.getElementById('gameInfo').style.display = 'block';
    }

    function startMainGame() {
      gameState = 'playing';
      timeLeft = difficultyTimes[document.getElementById('typeSelect').value];
      currentPhraseIndex = 0;
      selectNewPhrase();
      
      document.getElementById('translationInput').style.display = 'block';
      document.getElementById('inputTranslation').focus();
    }

    function selectNewPhrase() {
      if (currentPhraseIndex < currentRoundWords.length) {
        currentPhrase = currentRoundWords[currentPhraseIndex];
        // Reset translation status for new word
        window.currentWordTranslationCorrect = false;
        window.currentTranslationError = null;
        // Reset timer state
        timerPaused = false;
        // Hide continue button
        document.getElementById('continueButton').style.display = 'none';
        // Clear feedback
        document.getElementById('translationFeedback').innerHTML = '';
      } else {
        currentPhrase = null;
      }
    }

    async function submit() {
      if (gameState !== 'playing') return;
      if (!currentPhrase) return;
      
      const input = normalizeText(document.getElementById('inputTranslation').value);
      
      // Pausar el timer durante la validaci√≥n
      timerPaused = true;
      
      // Show loading state
      const submitButton = document.getElementById('submitButton');
      const originalText = submitButton.textContent;
      submitButton.textContent = 'ü§ñ Validando...';
      submitButton.disabled = true;
      
      // Hide continue button initially
      document.getElementById('continueButton').style.display = 'none';
      
      try {
        // Use AI validation
        const aiResult = await validateTranslationWithAI(currentPhrase.english, input);
        const isCorrect = aiResult.correct;
        
        if (isCorrect) {
          // NO incrementar score ni correctAnswers aqu√≠ - esperar a pronunciaci√≥n
          showCorrectFeedback();
          
          // Mark that translation was correct for this word
          window.currentWordTranslationCorrect = true;
          
          // Show AI feedback for correct answer
          if (aiResult.alternatives && aiResult.alternatives.length > 0) {
            showTranslationFeedback(`‚úÖ ¬°Correcto! Otras traducciones v√°lidas: ${aiResult.alternatives.join(', ')}<br><br>üé§ Ahora procederemos con la pronunciaci√≥n para evaluaci√≥n completa.`, 'success');
          } else {
            showTranslationFeedback(`‚úÖ ¬°Excelente! Tu traducci√≥n es correcta.<br><br>üé§ Ahora procederemos con la pronunciaci√≥n para evaluaci√≥n completa.`, 'success');
          }
        } else {
          // NO incrementar incorrectTranslations aqu√≠ - esperar a pronunciaci√≥n
          window.currentWordTranslationCorrect = false;
          
          // Temporal storage for translation error
          window.currentTranslationError = {
            word: currentPhrase.english,
            expected: currentPhrase.spanish.join(' / '),
            userInput: input,
            pronunciation: currentPhrase.pronunciation,
            phonetic: currentPhrase.phonetic,
            translationError: true,
            pronunciationError: false,
            pronunciationScore: null,
            aiExplanation: aiResult.explanation,
            aiAlternatives: aiResult.alternatives || []
          };
          
          showIncorrectFeedback();
          
          // Show AI explanation
          showTranslationFeedback(`‚ùå ${aiResult.explanation}<br><br>üé§ A√∫n as√≠, procederemos con la pronunciaci√≥n para evaluaci√≥n completa.`, 'error');
        }
        
        document.getElementById('inputTranslation').value = '';
        
        // Show continue button
        document.getElementById('continueButton').style.display = 'block';
        
      } catch (error) {
        console.error('Error during validation:', error);
        // Fallback to original logic
        const correctAnswers_local = currentPhrase.spanish;
        const isCorrect = correctAnswers_local.includes(input);
        
        if (isCorrect) {
          // NO incrementar score aqu√≠ - esperar a pronunciaci√≥n
          showCorrectFeedback();
          window.currentWordTranslationCorrect = true;
          showTranslationFeedback(`‚úÖ ¬°Correcto!<br><br>üé§ Ahora procederemos con la pronunciaci√≥n.`, 'success');
        } else {
          // NO incrementar incorrectTranslations aqu√≠ - esperar a pronunciaci√≥n
          window.currentWordTranslationCorrect = false;
          
          // Temporal storage for translation error
          window.currentTranslationError = {
            word: currentPhrase.english,
            expected: currentPhrase.spanish.join(' / '),
            userInput: input,
            pronunciation: currentPhrase.pronunciation,
            phonetic: currentPhrase.phonetic,
            translationError: true,
            pronunciationError: false,
            pronunciationScore: null
          };
          
          showIncorrectFeedback();
          showTranslationFeedback(`‚ùå Respuesta incorrecta. La traducci√≥n correcta es: ${currentPhrase.spanish.join(' / ')}<br><br>üé§ A√∫n as√≠, procederemos con la pronunciaci√≥n.`, 'error');
        }
        
        document.getElementById('inputTranslation').value = '';
        document.getElementById('continueButton').style.display = 'block';
      } finally {
        // Restore button state
        submitButton.textContent = originalText;
        submitButton.disabled = false;
      }
    }

    function continueToNextStep() {
      // Ocultar bot√≥n de continuar
      document.getElementById('continueButton').style.display = 'none';
      
      // Limpiar feedback
      document.getElementById('translationFeedback').innerHTML = '';
      
      // Reanudar el timer
      timerPaused = false;
      
      // Continuar al siguiente paso (pronunciaci√≥n)
      startVoiceRecognitionPhase();
    }

    function handleTimeout() {
      // Solo procesar timeout si el timer no est√° pausado
      if (timerPaused) return;
      
      // NO incrementar incorrectTranslations aqu√≠ - esperar a pronunciaci√≥n
      window.currentWordTranslationCorrect = false;
      
      if (currentPhrase) {
        // Temporal storage for timeout error
        window.currentTranslationError = {
          word: currentPhrase.english,
          expected: currentPhrase.spanish.join(' / '),
          userInput: '(timeout)',
          pronunciation: currentPhrase.pronunciation,
          phonetic: currentPhrase.phonetic,
          translationError: true,
          pronunciationError: false,
          pronunciationScore: null,
          aiExplanation: 'Se agot√≥ el tiempo para responder',
          aiAlternatives: currentPhrase.spanish || []
        };
      }
      
      showTimeoutFeedback();
      showTranslationFeedback(`‚è±Ô∏è Se agot√≥ el tiempo. La respuesta correcta era: ${currentPhrase.spanish.join(' / ')}<br><br>üé§ A√∫n as√≠, procederemos con la pronunciaci√≥n.`, 'error');
      
      // Show continue button for timeout too
      document.getElementById('continueButton').style.display = 'block';
    }

    function nextRound() {
      round++;
      currentPhraseIndex++;
      
      if (round >= roundSize || currentPhraseIndex >= currentRoundWords.length) {
        finishGame();
      } else {
        selectNewPhrase();
        resetTimer();
        
        gameState = 'playing';
        document.getElementById('translationInput').style.display = 'block';
        document.getElementById('inputTranslation').focus();
      }
    }

    function finishGame() {
      totalGameTime = (millis() - startTime) / 1000;
      
      if (errors.length > 0) {
        showErrorReview();
      } else {
        gameState = 'finalResults';
        showFinalResults();
      }
    }

    async function showErrorReview() {
      gameState = 'errorReview';
      
      document.getElementById('gameInfo').style.display = 'none';
      document.getElementById('translationInput').style.display = 'none';
      document.getElementById('voiceRecognition').style.display = 'none';
      document.getElementById('errorsReview').style.display = 'block';
      
      const errorsList = document.getElementById('errorsList');
      errorsList.innerHTML = '<div style="text-align: center; color: #ffa726; margin: 20px 0;">ü§ñ Generando explicaciones inteligentes...</div>';
      
      if (errors.length === 0) {
        errorsList.innerHTML = `
          <div style="text-align: center; color: #4ecdc4; font-size: 1.2rem; padding: 20px;">
            üéâ ¬°Perfecto! No hubo errores en esta ronda.
          </div>
        `;
        return;
      }
      
      try {
        // Generate AI explanations
        const aiExplanations = await generateErrorExplanations(errors);
        
        errorsList.innerHTML = '';
        
        errors.forEach((error, index) => {
          const errorItem = document.createElement('div');
          errorItem.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            text-align: left;
          `;
          
          // Determinar tipo de error y clase CSS
          let errorBadgeClass = '';
          let errorTypeText = '';
          if (error.translationError && error.pronunciationError) {
            errorBadgeClass = 'error-both';
            errorTypeText = 'üö´ Error en Traducci√≥n y Pronunciaci√≥n';
          } else if (error.translationError) {
            errorBadgeClass = 'error-translation';
            errorTypeText = 'üìù Error en Traducci√≥n (Pronunciaci√≥n correcta)';
          } else if (error.pronunciationError) {
            errorBadgeClass = 'error-pronunciation';
            errorTypeText = 'üîä Error en Pronunciaci√≥n (Traducci√≥n correcta)';
          }
          
          // Add overall result indicator
          let overallResult = '';
          if (error.translationError || error.pronunciationError) {
            overallResult = `
              <div style="background: rgba(255, 71, 87, 0.2); border: 1px solid #ff4757; border-radius: 8px; padding: 8px; margin: 8px 0; text-align: center;">
                <span style="color: #ff4757; font-weight: 700; font-size: 1rem;">‚ùå RESPUESTA INCORRECTA</span><br>
                <span style="color: rgba(255, 255, 255, 0.8); font-size: 0.85rem;">
                  ${error.translationError && error.pronunciationError ? 'Ambas partes fallaron' : 
                    error.translationError ? 'Fall√≥ por traducci√≥n incorrecta' : 'Fall√≥ por pronunciaci√≥n incorrecta'}
                </span>
              </div>
            `;
          }
          
          let errorContent = `
            <div style="color: #ffd700; font-size: 1.2rem; font-weight: 600; margin-bottom: 8px;">
              ${index + 1}. "${error.word}"
            </div>
            ${overallResult}
            <div class="error-type-badge ${errorBadgeClass}">
              ${errorTypeText}
            </div>
            <div style="color: rgba(255, 255, 255, 0.9); font-size: 0.95rem; line-height: 1.4;">
          `;
          
          // Solo mostrar informaci√≥n de traducci√≥n si hubo error de traducci√≥n
          if (error.translationError) {
            errorContent += `
              <div style="margin: 5px 0;">‚úÖ <span style="color: #4ecdc4; font-weight: 500;">Traducci√≥n correcta: ${error.expected}</span></div>
              <div style="margin: 5px 0;">‚ùå <span style="color: #ff6b6b; font-weight: 500;">Tu respuesta: ${error.userInput}</span></div>
            `;
            
            // Show AI alternatives if available
            if (error.aiAlternatives && error.aiAlternatives.length > 0) {
              errorContent += `
                <div style="margin: 5px 0;">üí° <span style="color: #ffa726; font-weight: 500;">Otras traducciones v√°lidas: ${error.aiAlternatives.join(', ')}</span></div>
              `;
            }
          }
          
          // Siempre mostrar la pronunciaci√≥n correcta
          errorContent += `
            <div style="margin: 5px 0;">üîä <span style="color: #4ecdc4; font-weight: 500;">Pronunciaci√≥n: ${error.phonetic}</span></div>
          `;
          
          // Mostrar puntuaci√≥n de pronunciaci√≥n si la hubo
          if (error.pronunciationScore !== undefined && error.pronunciationScore !== null) {
            const scoreColor = error.pronunciationScore >= 70 ? '#4ecdc4' : error.pronunciationScore >= 50 ? '#ffa726' : '#ff6b6b';
            errorContent += `
              <div style="margin: 5px 0;">üéØ <span style="color: ${scoreColor}; font-weight: 500;">Puntuaci√≥n de pronunciaci√≥n: ${error.pronunciationScore}%</span></div>
            `;
            
            // Show detailed pronunciation analysis if available
            if (error.pronunciationData && error.pronunciationData.detailedResults) {
              errorContent += `
                <div style="margin: 10px 0; padding: 10px; background: rgba(255, 167, 38, 0.1); border-radius: 8px; border-left: 3px solid #ffa726;">
                  <div style="color: #ffa726; font-weight: 600; margin-bottom: 5px;">üìä An√°lisis detallado de pronunciaci√≥n:</div>
                  <div style="color: rgba(255, 255, 255, 0.9); font-size: 0.85rem;">
                    ‚Ä¢ Promedio de ${error.pronunciationData.rounds} rondas: ${error.pronunciationData.averageScore}%<br>
              `;
              
              // Show individual round scores
              error.pronunciationData.detailedResults.forEach((result, idx) => {
                errorContent += `‚Ä¢ Ronda ${idx + 1}: ${result.overall.toFixed(1)}% (Precisi√≥n: ${result.accuracy.toFixed(1)}%, Claridad: ${result.clarity.toFixed(1)}%)<br>`;
              });
              
              // Show AI analysis if available
              if (error.pronunciationData.aiAnalysis && error.pronunciationData.aiAnalysis.length > 0) {
                const bestAnalysis = error.pronunciationData.aiAnalysis[error.pronunciationData.aiAnalysis.length - 1];
                if (bestAnalysis.feedback) {
                  errorContent += `<br><strong>ü§ñ An√°lisis de IA:</strong> ${bestAnalysis.feedback}`;
                }
                if (bestAnalysis.tips) {
                  errorContent += `<br><strong>üí° Consejo:</strong> ${bestAnalysis.tips}`;
                }
                if (bestAnalysis.strongPoints) {
                  errorContent += `<br><strong>‚úÖ Puntos fuertes:</strong> ${bestAnalysis.strongPoints}`;
                }
                if (bestAnalysis.improvementAreas) {
                  errorContent += `<br><strong>üìà √Åreas de mejora:</strong> ${bestAnalysis.improvementAreas}`;
                }
              }
              
              errorContent += `
                  </div>
                </div>
              `;
            }
          }
          
          // Add AI explanation
          const aiExplanation = aiExplanations.find(exp => exp.word === error.word);
          if (aiExplanation) {
            errorContent += `
              <div style="margin: 10px 0; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 8px; border-left: 3px solid #4ecdc4;">
                <div style="color: #4ecdc4; font-weight: 600; margin-bottom: 5px;">ü§ñ Explicaci√≥n de la IA:</div>
                <div style="color: rgba(255, 255, 255, 0.9); font-size: 0.9rem;">${aiExplanation.explanation}</div>
                ${aiExplanation.tips ? `<div style="color: #ffa726; margin-top: 5px; font-size: 0.9rem;">üí° <strong>Consejo:</strong> ${aiExplanation.tips}</div>` : ''}
              </div>
            `;
          } else if (error.aiExplanation) {
            errorContent += `
              <div style="margin: 10px 0; padding: 10px; background: rgba(78, 205, 196, 0.1); border-radius: 8px; border-left: 3px solid #4ecdc4;">
                <div style="color: #4ecdc4; font-weight: 600; margin-bottom: 5px;">ü§ñ Explicaci√≥n:</div>
                <div style="color: rgba(255, 255, 255, 0.9); font-size: 0.9rem;">${error.aiExplanation}</div>
              </div>
            `;
          }
          
          errorContent += '</div>';
          errorItem.innerHTML = errorContent;
          errorsList.appendChild(errorItem);
        });
        
      } catch (error) {
        console.error('Error generating AI explanations:', error);
        // Fallback to basic error display
        errorsList.innerHTML = '';
        
        errors.forEach((error, index) => {
          const errorItem = document.createElement('div');
          errorItem.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            text-align: left;
          `;
          
          errorItem.innerHTML = `
            <div style="color: #ffd700; font-size: 1.2rem; font-weight: 600; margin-bottom: 8px;">
              ${index + 1}. "${error.word}"
            </div>
            <div style="color: rgba(255, 255, 255, 0.9); font-size: 0.95rem; line-height: 1.4;">
              <div>‚úÖ <span style="color: #4ecdc4; font-weight: 500;">Correcto: ${error.expected}</span></div>
              <div>‚ùå <span style="color: #ff6b6b; font-weight: 500;">Tu respuesta: ${error.userInput}</span></div>
              <div>üîä <span style="color: #4ecdc4; font-weight: 500;">Pronunciaci√≥n: ${error.phonetic}</span></div>
            </div>
          `;
          errorsList.appendChild(errorItem);
        });
      }
    }

    function startRetryRound() {
      resetGameState();
      gameState = 'countdown';
      countdownTimer = millis();
      startTime = millis();
      
      document.getElementById('errorsReview').style.display = 'none';
      showGameElements();
    }

    function showFinalResults() {
      document.getElementById('gameInfo').style.display = 'none';
      document.getElementById('translationInput').style.display = 'none';
      document.getElementById('voiceRecognition').style.display = 'none';
      document.getElementById('errorsReview').style.display = 'none';
      
      gameState = 'finalResults';
      
      setTimeout(() => {
        document.getElementById('controlsPanel').style.display = 'flex';
        document.getElementById('startButton').style.display = 'block';
        document.getElementById('fileInfo').style.display = 'block';
      }, 3000);
    }

    function resetTimer() {
      timeLeft = difficultyTimes[document.getElementById('typeSelect').value];
      timerPaused = false; // Asegurar que el timer no est√© pausado
      document.getElementById('inputTranslation').focus();
    }

    function showCorrectFeedback() {
      const input = document.getElementById('inputTranslation');
      input.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
      input.style.borderColor = '#4CAF50';
      
      setTimeout(() => {
        input.style.backgroundColor = '';
        input.style.borderColor = '';
      }, 1000);
    }

    function showIncorrectFeedback() {
      const input = document.getElementById('inputTranslation');
      input.style.backgroundColor = 'rgba(244, 67, 54, 0.3)';
      input.style.borderColor = '#F44336';
      input.style.animation = 'shake 0.5s ease-in-out';
      
      setTimeout(() => {
        input.style.backgroundColor = '';
        input.style.borderColor = '';
        input.style.animation = 'none';
      }, 1000);
    }

    function showTimeoutFeedback() {
      const timer = document.getElementById('timerDisplay');
      const originalBg = timer.style.backgroundColor;
      timer.style.backgroundColor = 'rgba(244, 67, 54, 0.5)';
      timer.style.animation = 'shake 0.5s ease-in-out';
      
      setTimeout(() => {
        timer.style.backgroundColor = originalBg;
        timer.style.animation = 'none';
      }, 1000);
    }

    function getCurrentUser() {
      return 'GerarAbdiel';
    }

    function getCurrentDateTime() {
      return '2025-06-20 23:37:03';
    }

    // Event listeners
    document.getElementById('startButton').addEventListener('click', startPlaying);
    document.getElementById('submitButton').addEventListener('click', submit);
    document.getElementById('continueButton').addEventListener('click', continueToNextStep);
    document.getElementById('micButton').addEventListener('click', startRecording);
    document.getElementById('playPronunciation').addEventListener('click', () => playPronunciation(1.0));
    document.getElementById('playSlowPronunciation').addEventListener('click', playSlowPronunciation);
    document.getElementById('repeatPronunciation').addEventListener('click', playRepeatPronunciation);
    document.getElementById('retryButton').addEventListener('click', startRetryRound);

    document.getElementById('inputTranslation').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        submit();
      }
    });

    document.getElementById('inputTranslation').addEventListener('input', function() {
      const submitBtn = document.getElementById('submitButton');
      submitBtn.disabled = this.value.trim() === '';
    });

    document.addEventListener('keydown', function(e) {
      if (gameState === 'voiceRecognition' && e.key === ' ') {
        e.preventDefault();
        startRecording();
      }
    });

    // Initialize enhanced game
    window.addEventListener('load', function() {
      console.log('üéÆ Translate Blitz Pro - Offline AI Edition loaded successfully!');
      console.log(`üìö Dictionary with ${Object.keys(translationDictionary).length} entries ready!`);
      console.log(`üëã Welcome, ${getCurrentUser()}!`);
      console.log(`üìÖ Current Date: ${getCurrentDateTime()}`);
      console.log('üé§ Enhanced voice recognition with amplification initialized');
      console.log('üîä Relaxed pronunciation matching enabled (50%+ acceptance)');
      console.log('üéµ Unlimited audio repetition available');
      console.log('ü§ñ Offline AI system with semantic analysis active');
    });

  </script>
</body>
</html>
